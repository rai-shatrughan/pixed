// Code generated by go-swagger; DO NOT EDIT.

package time_series_operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"net/http"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/runtime/middleware"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// NewRetrieveTimeseriesParams creates a new RetrieveTimeseriesParams object
// with the default values initialized.
func NewRetrieveTimeseriesParams() RetrieveTimeseriesParams {

	var (
		// initialize parameters with default values

		latestValueDefault = bool(false)
		limitDefault       = int64(2000)

		sortDefault = string("asc")
	)

	return RetrieveTimeseriesParams{
		LatestValue: &latestValueDefault,

		Limit: &limitDefault,

		Sort: &sortDefault,
	}
}

// RetrieveTimeseriesParams contains all the bound params for the retrieve timeseries operation
// typically these are obtained from a http.Request
//
// swagger:parameters retrieveTimeseries
type RetrieveTimeseriesParams struct {

	// HTTP Request Object
	HTTPRequest *http.Request `json:"-"`

	/*unique identifier of the asset (entity)
	  Required: true
	  Max Length: 32
	  Min Length: 32
	  Pattern: [a-f0-9]{32}
	  In: path
	*/
	EntityID string
	/*Beginning of the time range to be retrieved (exclusive).
	  In: query
	*/
	From *strfmt.DateTime
	/*If true, only the latest value of each property is returned. Latest values must be at least two hours old and at maximum 30 days old, in order to be considered. The returned values might be co-located or spread over multiple timestamps. Each property appears at max once in the response. The select parameter can be used to limit the properties to be considered. Parameters from, to, and limit must not be used in conjunction with latest. The response only includes latest value with good and uncertain quality codes
	  In: query
	  Default: false
	*/
	LatestValue *bool
	/*Maximum number of time series data items to be retrieved.
	  Maximum: 2000
	  In: query
	  Default: 2000
	*/
	Limit *int64
	/*Name of the aspect (property set).
	  Required: true
	  In: path
	*/
	PropertySetName string
	/*Comma-separated list of properties to be returned. By default all properties of an(a) aspect (property set) are considered.
	  In: query
	*/
	Select *string
	/*Define sorting order of returned data. Sorting can be chronologically ascending (<i>asc</i>) or descending (<i>desc</i>).
	  In: query
	  Default: "asc"
	*/
	Sort *string
	/*End of the time range to be retrieved (inclusive).
	  In: query
	*/
	To *strfmt.DateTime
}

// BindRequest both binds and validates a request, it assumes that complex things implement a Validatable(strfmt.Registry) error interface
// for simple values it will use straight method calls.
//
// To ensure default values, the struct must have been initialized with NewRetrieveTimeseriesParams() beforehand.
func (o *RetrieveTimeseriesParams) BindRequest(r *http.Request, route *middleware.MatchedRoute) error {
	var res []error

	o.HTTPRequest = r

	qs := runtime.Values(r.URL.Query())

	rEntityID, rhkEntityID, _ := route.Params.GetOK("entityId")
	if err := o.bindEntityID(rEntityID, rhkEntityID, route.Formats); err != nil {
		res = append(res, err)
	}

	qFrom, qhkFrom, _ := qs.GetOK("from")
	if err := o.bindFrom(qFrom, qhkFrom, route.Formats); err != nil {
		res = append(res, err)
	}

	qLatestValue, qhkLatestValue, _ := qs.GetOK("latestValue")
	if err := o.bindLatestValue(qLatestValue, qhkLatestValue, route.Formats); err != nil {
		res = append(res, err)
	}

	qLimit, qhkLimit, _ := qs.GetOK("limit")
	if err := o.bindLimit(qLimit, qhkLimit, route.Formats); err != nil {
		res = append(res, err)
	}

	rPropertySetName, rhkPropertySetName, _ := route.Params.GetOK("propertySetName")
	if err := o.bindPropertySetName(rPropertySetName, rhkPropertySetName, route.Formats); err != nil {
		res = append(res, err)
	}

	qSelect, qhkSelect, _ := qs.GetOK("select")
	if err := o.bindSelect(qSelect, qhkSelect, route.Formats); err != nil {
		res = append(res, err)
	}

	qSort, qhkSort, _ := qs.GetOK("sort")
	if err := o.bindSort(qSort, qhkSort, route.Formats); err != nil {
		res = append(res, err)
	}

	qTo, qhkTo, _ := qs.GetOK("to")
	if err := o.bindTo(qTo, qhkTo, route.Formats); err != nil {
		res = append(res, err)
	}
	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// bindEntityID binds and validates parameter EntityID from path.
func (o *RetrieveTimeseriesParams) bindEntityID(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: true
	// Parameter is provided by construction from the route
	o.EntityID = raw

	if err := o.validateEntityID(formats); err != nil {
		return err
	}

	return nil
}

// validateEntityID carries on validations for parameter EntityID
func (o *RetrieveTimeseriesParams) validateEntityID(formats strfmt.Registry) error {

	if err := validate.MinLength("entityId", "path", o.EntityID, 32); err != nil {
		return err
	}

	if err := validate.MaxLength("entityId", "path", o.EntityID, 32); err != nil {
		return err
	}

	if err := validate.Pattern("entityId", "path", o.EntityID, `[a-f0-9]{32}`); err != nil {
		return err
	}

	return nil
}

// bindFrom binds and validates parameter From from query.
func (o *RetrieveTimeseriesParams) bindFrom(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}

	// Format: date-time
	value, err := formats.Parse("date-time", raw)
	if err != nil {
		return errors.InvalidType("from", "query", "strfmt.DateTime", raw)
	}
	o.From = (value.(*strfmt.DateTime))

	if err := o.validateFrom(formats); err != nil {
		return err
	}

	return nil
}

// validateFrom carries on validations for parameter From
func (o *RetrieveTimeseriesParams) validateFrom(formats strfmt.Registry) error {

	if err := validate.FormatOf("from", "query", "date-time", o.From.String(), formats); err != nil {
		return err
	}
	return nil
}

// bindLatestValue binds and validates parameter LatestValue from query.
func (o *RetrieveTimeseriesParams) bindLatestValue(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		// Default values have been previously initialized by NewRetrieveTimeseriesParams()
		return nil
	}

	value, err := swag.ConvertBool(raw)
	if err != nil {
		return errors.InvalidType("latestValue", "query", "bool", raw)
	}
	o.LatestValue = &value

	return nil
}

// bindLimit binds and validates parameter Limit from query.
func (o *RetrieveTimeseriesParams) bindLimit(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		// Default values have been previously initialized by NewRetrieveTimeseriesParams()
		return nil
	}

	value, err := swag.ConvertInt64(raw)
	if err != nil {
		return errors.InvalidType("limit", "query", "int64", raw)
	}
	o.Limit = &value

	if err := o.validateLimit(formats); err != nil {
		return err
	}

	return nil
}

// validateLimit carries on validations for parameter Limit
func (o *RetrieveTimeseriesParams) validateLimit(formats strfmt.Registry) error {

	if err := validate.MaximumInt("limit", "query", *o.Limit, 2000, false); err != nil {
		return err
	}

	return nil
}

// bindPropertySetName binds and validates parameter PropertySetName from path.
func (o *RetrieveTimeseriesParams) bindPropertySetName(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: true
	// Parameter is provided by construction from the route
	o.PropertySetName = raw

	return nil
}

// bindSelect binds and validates parameter Select from query.
func (o *RetrieveTimeseriesParams) bindSelect(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}
	o.Select = &raw

	return nil
}

// bindSort binds and validates parameter Sort from query.
func (o *RetrieveTimeseriesParams) bindSort(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		// Default values have been previously initialized by NewRetrieveTimeseriesParams()
		return nil
	}
	o.Sort = &raw

	if err := o.validateSort(formats); err != nil {
		return err
	}

	return nil
}

// validateSort carries on validations for parameter Sort
func (o *RetrieveTimeseriesParams) validateSort(formats strfmt.Registry) error {

	if err := validate.EnumCase("sort", "query", *o.Sort, []interface{}{"asc", "desc"}, true); err != nil {
		return err
	}

	return nil
}

// bindTo binds and validates parameter To from query.
func (o *RetrieveTimeseriesParams) bindTo(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}

	// Format: date-time
	value, err := formats.Parse("date-time", raw)
	if err != nil {
		return errors.InvalidType("to", "query", "strfmt.DateTime", raw)
	}
	o.To = (value.(*strfmt.DateTime))

	if err := o.validateTo(formats); err != nil {
		return err
	}

	return nil
}

// validateTo carries on validations for parameter To
func (o *RetrieveTimeseriesParams) validateTo(formats strfmt.Registry) error {

	if err := validate.FormatOf("to", "query", "date-time", o.To.String(), formats); err != nil {
		return err
	}
	return nil
}
