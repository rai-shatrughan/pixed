// Code generated by go-swagger; DO NOT EDIT.

package time_series_operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the generate command

import (
	"net/http"

	"github.com/go-openapi/runtime/middleware"

	"gsvc/api/ts/models"
)

// CreateOrMergeTimeseriesHandlerFunc turns a function with the right signature into a create or merge timeseries handler
type CreateOrMergeTimeseriesHandlerFunc func(CreateOrMergeTimeseriesParams, *models.Principal) middleware.Responder

// Handle executing the request and returning a response
func (fn CreateOrMergeTimeseriesHandlerFunc) Handle(params CreateOrMergeTimeseriesParams, principal *models.Principal) middleware.Responder {
	return fn(params, principal)
}

// CreateOrMergeTimeseriesHandler interface for that can handle valid create or merge timeseries params
type CreateOrMergeTimeseriesHandler interface {
	Handle(CreateOrMergeTimeseriesParams, *models.Principal) middleware.Responder
}

// NewCreateOrMergeTimeseries creates a new http.Handler for the create or merge timeseries operation
func NewCreateOrMergeTimeseries(ctx *middleware.Context, handler CreateOrMergeTimeseriesHandler) *CreateOrMergeTimeseries {
	return &CreateOrMergeTimeseries{Context: ctx, Handler: handler}
}

/*
	CreateOrMergeTimeseries swagger:route PATCH /timeseries/{entityId}/{propertySetName} Time Series Operations createOrMergeTimeseries

# Create or merge time series data

Create or merge time series data for one combination of an asset (entity) and an(a) aspect (property set). This api creates or merges the data when different devices Or 3rd party apps write to different variables but within one aspect (property set) and same timestamp. Only those properties will be replaced by the ones provided in the request.

Request body limitations:
1. It may take several minutes after response until the provided changes are fully merged.
2. The number of updates being processed simultaneously by the service is limited.
3. The number of requests being accepted for processing is limited per time frame.
4. The maximum size of acceptable request bodies is 600 KB.
5. The maximum time range for PATCH request can't be older than 24 hours from current time. For example, if customer want to patch some timeseries record ingested for current time T; it needs to be patched maximum within T+24 hours
6. The PATCH will not work on Future timestamp at the time of execution.
7. The merge functionality does not support to create or update the variable value having data type as BigString.
8. The maximum number of records supported in one request is 10.
9. In case of errors, none of the changes for the provided time stamps will be applied.

**Example**

*Example 1: If we have asset (entity) which can send two sensor values say 'pressure' & 'temperature'. Then the asset (entity) can send two separate calls to IoT for same device timesamp as below:*

	Call-1: This is a put request
	  TS record for tenant1\asset1\aspect1
	  {
	      "_time" : "2020-01-01T23:00:00.000Z",
	      "pressure" : 42.56
	  }

	Call-2: This is a patch request
	  TS record for tenant1\asset1\aspect1
	  {
	    "_time" : "2020-01-01T23:00:00.000Z",
	    "temperature" : 73.23
	  }

After above two TimeSeries ingest calls, if we make GET call for this tenant-asset-aspect combination and for the same device timestamp, then expected output should have merged results from both the calls. This means the output should look as below:

	TS record for tenant1\asset1\aspect1
	{
	  "_time" : "2020-01-01T23:00:00.000Z",
	  "pressure" : 42.56,
	  "temperature" : 73.23
	}
*/
type CreateOrMergeTimeseries struct {
	Context *middleware.Context
	Handler CreateOrMergeTimeseriesHandler
}

func (o *CreateOrMergeTimeseries) ServeHTTP(rw http.ResponseWriter, r *http.Request) {
	route, rCtx, _ := o.Context.RouteInfo(r)
	if rCtx != nil {
		*r = *rCtx
	}
	var Params = NewCreateOrMergeTimeseriesParams()
	uprinc, aCtx, err := o.Context.Authorize(r, route)
	if err != nil {
		o.Context.Respond(rw, r, route.Produces, route, err)
		return
	}
	if aCtx != nil {
		*r = *aCtx
	}
	var principal *models.Principal
	if uprinc != nil {
		principal = uprinc.(*models.Principal) // this is really a models.Principal, I promise
	}

	if err := o.Context.BindValidRequest(r, route, &Params); err != nil { // bind params
		o.Context.Respond(rw, r, route.Produces, route, err)
		return
	}

	res := o.Handler.Handle(Params, principal) // actually handle the request
	o.Context.Respond(rw, r, route.Produces, route, res)

}
