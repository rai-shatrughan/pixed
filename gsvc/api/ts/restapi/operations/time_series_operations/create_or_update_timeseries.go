// Code generated by go-swagger; DO NOT EDIT.

package time_series_operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the generate command

import (
	"net/http"

	"github.com/go-openapi/runtime/middleware"

	"gsvc/api/ts/models"
)

// CreateOrUpdateTimeseriesHandlerFunc turns a function with the right signature into a create or update timeseries handler
type CreateOrUpdateTimeseriesHandlerFunc func(CreateOrUpdateTimeseriesParams, *models.Principal) middleware.Responder

// Handle executing the request and returning a response
func (fn CreateOrUpdateTimeseriesHandlerFunc) Handle(params CreateOrUpdateTimeseriesParams, principal *models.Principal) middleware.Responder {
	return fn(params, principal)
}

// CreateOrUpdateTimeseriesHandler interface for that can handle valid create or update timeseries params
type CreateOrUpdateTimeseriesHandler interface {
	Handle(CreateOrUpdateTimeseriesParams, *models.Principal) middleware.Responder
}

// NewCreateOrUpdateTimeseries creates a new http.Handler for the create or update timeseries operation
func NewCreateOrUpdateTimeseries(ctx *middleware.Context, handler CreateOrUpdateTimeseriesHandler) *CreateOrUpdateTimeseries {
	return &CreateOrUpdateTimeseries{Context: ctx, Handler: handler}
}

/*
	CreateOrUpdateTimeseries swagger:route PUT /timeseries Time Series Operations createOrUpdateTimeseries

Create or update time series data for mutiple unique asset-aspect (entity-property set) combinations.

Create or update time series data for multiple unique combinations of assets (entities) and aspects (property sets).
In case of an update of data at an already existing time, all properties at that time will be replaced by the ones provided in the request. All asset-aspect (entity-property set) combinations need to belong to the same tenant.

Request body limitations:
1. A maximum of 5  asset-aspect (entity-property set) combinations can be provided
2. The request body size must be equal or less than 100 kb
3. A maximum of 100 time series data items can be provided overall
*/
type CreateOrUpdateTimeseries struct {
	Context *middleware.Context
	Handler CreateOrUpdateTimeseriesHandler
}

func (o *CreateOrUpdateTimeseries) ServeHTTP(rw http.ResponseWriter, r *http.Request) {
	route, rCtx, _ := o.Context.RouteInfo(r)
	if rCtx != nil {
		*r = *rCtx
	}
	var Params = NewCreateOrUpdateTimeseriesParams()
	uprinc, aCtx, err := o.Context.Authorize(r, route)
	if err != nil {
		o.Context.Respond(rw, r, route.Produces, route, err)
		return
	}
	if aCtx != nil {
		*r = *aCtx
	}
	var principal *models.Principal
	if uprinc != nil {
		principal = uprinc.(*models.Principal) // this is really a models.Principal, I promise
	}

	if err := o.Context.BindValidRequest(r, route, &Params); err != nil { // bind params
		o.Context.Respond(rw, r, route.Produces, route, err)
		return
	}

	res := o.Handler.Handle(Params, principal) // actually handle the request
	o.Context.Respond(rw, r, route.Produces, route, res)

}
