// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// AspectTypePatch aspect type patch
//
// swagger:model AspectTypePatch
type AspectTypePatch struct {

	// If the aspect-type is used for static data or time-series. Cannot be changed once the aspect-type is created.
	// Enum: [static dynamic]
	Category string `json:"category,omitempty"`

	// The description of the aspect type
	// Example: The engine of the Millenium Falcon
	// Max Length: 255
	// Pattern: [^\']*
	Description string `json:"description,omitempty"`

	// Name of the aspect type. It has to be unique inside the tenant and cannot be changed later.
	// Example: engine
	// Max Length: 128
	// Min Length: 1
	// Pattern: [a-zA-Z0-9_]+
	Name string `json:"name,omitempty"`

	// Visibility of aspecttype. Setting this property to public makes it available to other tenants. Private types are only visible to the user's own tenant. Currently only private types can be created.
	// Example: private
	// Enum: [public private]
	Scope *string `json:"scope,omitempty"`

	// Variables of the aspect-type. Variable names should be unique inside an aspect-type.
	// Min Items: 1
	Variables []*AspectVariable `json:"variables"`
}

// Validate validates this aspect type patch
func (m *AspectTypePatch) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCategory(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDescription(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateScope(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVariables(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var aspectTypePatchTypeCategoryPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["static","dynamic"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		aspectTypePatchTypeCategoryPropEnum = append(aspectTypePatchTypeCategoryPropEnum, v)
	}
}

const (

	// AspectTypePatchCategoryStatic captures enum value "static"
	AspectTypePatchCategoryStatic string = "static"

	// AspectTypePatchCategoryDynamic captures enum value "dynamic"
	AspectTypePatchCategoryDynamic string = "dynamic"
)

// prop value enum
func (m *AspectTypePatch) validateCategoryEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, aspectTypePatchTypeCategoryPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *AspectTypePatch) validateCategory(formats strfmt.Registry) error {
	if swag.IsZero(m.Category) { // not required
		return nil
	}

	// value enum
	if err := m.validateCategoryEnum("category", "body", m.Category); err != nil {
		return err
	}

	return nil
}

func (m *AspectTypePatch) validateDescription(formats strfmt.Registry) error {
	if swag.IsZero(m.Description) { // not required
		return nil
	}

	if err := validate.MaxLength("description", "body", m.Description, 255); err != nil {
		return err
	}

	if err := validate.Pattern("description", "body", m.Description, `[^\']*`); err != nil {
		return err
	}

	return nil
}

func (m *AspectTypePatch) validateName(formats strfmt.Registry) error {
	if swag.IsZero(m.Name) { // not required
		return nil
	}

	if err := validate.MinLength("name", "body", m.Name, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("name", "body", m.Name, 128); err != nil {
		return err
	}

	if err := validate.Pattern("name", "body", m.Name, `[a-zA-Z0-9_]+`); err != nil {
		return err
	}

	return nil
}

var aspectTypePatchTypeScopePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["public","private"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		aspectTypePatchTypeScopePropEnum = append(aspectTypePatchTypeScopePropEnum, v)
	}
}

const (

	// AspectTypePatchScopePublic captures enum value "public"
	AspectTypePatchScopePublic string = "public"

	// AspectTypePatchScopePrivate captures enum value "private"
	AspectTypePatchScopePrivate string = "private"
)

// prop value enum
func (m *AspectTypePatch) validateScopeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, aspectTypePatchTypeScopePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *AspectTypePatch) validateScope(formats strfmt.Registry) error {
	if swag.IsZero(m.Scope) { // not required
		return nil
	}

	// value enum
	if err := m.validateScopeEnum("scope", "body", *m.Scope); err != nil {
		return err
	}

	return nil
}

func (m *AspectTypePatch) validateVariables(formats strfmt.Registry) error {
	if swag.IsZero(m.Variables) { // not required
		return nil
	}

	iVariablesSize := int64(len(m.Variables))

	if err := validate.MinItems("variables", "body", iVariablesSize, 1); err != nil {
		return err
	}

	for i := 0; i < len(m.Variables); i++ {
		if swag.IsZero(m.Variables[i]) { // not required
			continue
		}

		if m.Variables[i] != nil {
			if err := m.Variables[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("variables" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("variables" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this aspect type patch based on the context it is used
func (m *AspectTypePatch) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateVariables(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AspectTypePatch) contextValidateVariables(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Variables); i++ {

		if m.Variables[i] != nil {
			if err := m.Variables[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("variables" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("variables" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *AspectTypePatch) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AspectTypePatch) UnmarshalBinary(b []byte) error {
	var res AspectTypePatch
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
