// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// AspectType aspect type
//
// swagger:model AspectType
type AspectType struct {

	// If the aspect-type is used for static data or time-series. Cannot be changed once the aspect-type is created.
	// Required: true
	// Enum: [static dynamic]
	Category *string `json:"category"`

	// The description of the aspect type
	// Example: The engine of the Millenium Falcon
	// Max Length: 255
	// Pattern: [^\']*
	Description string `json:"description,omitempty"`

	// Name of the aspect type. It has to be unique inside the tenant and cannot be changed later.
	// Example: engine
	// Required: true
	// Max Length: 128
	// Min Length: 1
	// Pattern: [a-zA-Z0-9_]+
	Name *string `json:"name"`

	// Visibility of aspecttype. Setting this property to public makes it available to other tenants. Private types are only visible to the user's own tenant. Currently only private types can be created.
	// Example: private
	// Required: true
	// Enum: [public private]
	Scope *string `json:"scope"`

	// Variables of the aspect-type. Variable names should be unique inside an aspect-type.
	// Required: true
	// Min Items: 1
	Variables []*AspectVariable `json:"variables"`
}

// Validate validates this aspect type
func (m *AspectType) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCategory(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDescription(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateScope(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVariables(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var aspectTypeTypeCategoryPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["static","dynamic"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		aspectTypeTypeCategoryPropEnum = append(aspectTypeTypeCategoryPropEnum, v)
	}
}

const (

	// AspectTypeCategoryStatic captures enum value "static"
	AspectTypeCategoryStatic string = "static"

	// AspectTypeCategoryDynamic captures enum value "dynamic"
	AspectTypeCategoryDynamic string = "dynamic"
)

// prop value enum
func (m *AspectType) validateCategoryEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, aspectTypeTypeCategoryPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *AspectType) validateCategory(formats strfmt.Registry) error {

	if err := validate.Required("category", "body", m.Category); err != nil {
		return err
	}

	// value enum
	if err := m.validateCategoryEnum("category", "body", *m.Category); err != nil {
		return err
	}

	return nil
}

func (m *AspectType) validateDescription(formats strfmt.Registry) error {
	if swag.IsZero(m.Description) { // not required
		return nil
	}

	if err := validate.MaxLength("description", "body", m.Description, 255); err != nil {
		return err
	}

	if err := validate.Pattern("description", "body", m.Description, `[^\']*`); err != nil {
		return err
	}

	return nil
}

func (m *AspectType) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	if err := validate.MinLength("name", "body", *m.Name, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("name", "body", *m.Name, 128); err != nil {
		return err
	}

	if err := validate.Pattern("name", "body", *m.Name, `[a-zA-Z0-9_]+`); err != nil {
		return err
	}

	return nil
}

var aspectTypeTypeScopePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["public","private"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		aspectTypeTypeScopePropEnum = append(aspectTypeTypeScopePropEnum, v)
	}
}

const (

	// AspectTypeScopePublic captures enum value "public"
	AspectTypeScopePublic string = "public"

	// AspectTypeScopePrivate captures enum value "private"
	AspectTypeScopePrivate string = "private"
)

// prop value enum
func (m *AspectType) validateScopeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, aspectTypeTypeScopePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *AspectType) validateScope(formats strfmt.Registry) error {

	if err := validate.Required("scope", "body", m.Scope); err != nil {
		return err
	}

	// value enum
	if err := m.validateScopeEnum("scope", "body", *m.Scope); err != nil {
		return err
	}

	return nil
}

func (m *AspectType) validateVariables(formats strfmt.Registry) error {

	if err := validate.Required("variables", "body", m.Variables); err != nil {
		return err
	}

	iVariablesSize := int64(len(m.Variables))

	if err := validate.MinItems("variables", "body", iVariablesSize, 1); err != nil {
		return err
	}

	for i := 0; i < len(m.Variables); i++ {
		if swag.IsZero(m.Variables[i]) { // not required
			continue
		}

		if m.Variables[i] != nil {
			if err := m.Variables[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("variables" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("variables" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this aspect type based on the context it is used
func (m *AspectType) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateVariables(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AspectType) contextValidateVariables(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Variables); i++ {

		if m.Variables[i] != nil {
			if err := m.Variables[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("variables" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("variables" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *AspectType) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AspectType) UnmarshalBinary(b []byte) error {
	var res AspectType
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
