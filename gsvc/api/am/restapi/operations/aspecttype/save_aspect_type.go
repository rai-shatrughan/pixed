// Code generated by go-swagger; DO NOT EDIT.

package aspecttype

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the generate command

import (
	"net/http"

	"github.com/go-openapi/runtime/middleware"

	"gsvc/api/am/models"
)

// SaveAspectTypeHandlerFunc turns a function with the right signature into a save aspect type handler
type SaveAspectTypeHandlerFunc func(SaveAspectTypeParams, *models.Principal) middleware.Responder

// Handle executing the request and returning a response
func (fn SaveAspectTypeHandlerFunc) Handle(params SaveAspectTypeParams, principal *models.Principal) middleware.Responder {
	return fn(params, principal)
}

// SaveAspectTypeHandler interface for that can handle valid save aspect type params
type SaveAspectTypeHandler interface {
	Handle(SaveAspectTypeParams, *models.Principal) middleware.Responder
}

// NewSaveAspectType creates a new http.Handler for the save aspect type operation
func NewSaveAspectType(ctx *middleware.Context, handler SaveAspectTypeHandler) *SaveAspectType {
	return &SaveAspectType{Context: ctx, Handler: handler}
}

/*
	SaveAspectType swagger:route PUT /aspecttypes/{id} aspecttype saveAspectType

# Create or Update an aspect type

Create or Update an aspect type. Only adding variables and restricted updates on variables is supported, like user can change unit details, can increase the length of a static STRING variable but length of a dynamic STRING variable cannot be changed. In order to rename or remove variable, use PATCH /aspecttypes/{id}/variables api. Default value field is available only for static aspect variables and not on dynamic aspect variable. Aspect type description should not contain single quote character.
*/
type SaveAspectType struct {
	Context *middleware.Context
	Handler SaveAspectTypeHandler
}

func (o *SaveAspectType) ServeHTTP(rw http.ResponseWriter, r *http.Request) {
	route, rCtx, _ := o.Context.RouteInfo(r)
	if rCtx != nil {
		*r = *rCtx
	}
	var Params = NewSaveAspectTypeParams()
	uprinc, aCtx, err := o.Context.Authorize(r, route)
	if err != nil {
		o.Context.Respond(rw, r, route.Produces, route, err)
		return
	}
	if aCtx != nil {
		*r = *aCtx
	}
	var principal *models.Principal
	if uprinc != nil {
		principal = uprinc.(*models.Principal) // this is really a models.Principal, I promise
	}

	if err := o.Context.BindValidRequest(r, route, &Params); err != nil { // bind params
		o.Context.Respond(rw, r, route.Produces, route, err)
		return
	}

	res := o.Handler.Handle(Params, principal) // actually handle the request
	o.Context.Respond(rw, r, route.Produces, route, res)

}
