// Code generated by go-swagger; DO NOT EDIT.

package files

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"io"
	"net/http"

	"github.com/go-openapi/runtime"

	"gsvc/api/am/models"
)

// DownloadFileOKCode is the HTTP code returned for type DownloadFileOK
const DownloadFileOKCode int = 200

/*
DownloadFileOK Returns the file

swagger:response downloadFileOK
*/
type DownloadFileOK struct {
	/*The uploaded file resource's media type

	 */
	ContentType string `json:"Content-Type"`

	/*The requested file as a base64 encoded string or an octet-stream
	  In: Body
	*/
	Payload io.ReadCloser `json:"body,omitempty"`
}

// NewDownloadFileOK creates DownloadFileOK with default headers values
func NewDownloadFileOK() *DownloadFileOK {

	return &DownloadFileOK{}
}

// WithContentType adds the contentType to the download file o k response
func (o *DownloadFileOK) WithContentType(contentType string) *DownloadFileOK {
	o.ContentType = contentType
	return o
}

// SetContentType sets the contentType to the download file o k response
func (o *DownloadFileOK) SetContentType(contentType string) {
	o.ContentType = contentType
}

// WithPayload adds the payload to the download file o k response
func (o *DownloadFileOK) WithPayload(payload io.ReadCloser) *DownloadFileOK {
	o.Payload = payload
	return o
}

// SetPayload sets the payload to the download file o k response
func (o *DownloadFileOK) SetPayload(payload io.ReadCloser) {
	o.Payload = payload
}

// WriteResponse to the client
func (o *DownloadFileOK) WriteResponse(rw http.ResponseWriter, producer runtime.Producer) {

	// response header Content-Type

	contentType := o.ContentType
	if contentType != "" {
		rw.Header().Set("Content-Type", contentType)
	}

	rw.WriteHeader(200)
	payload := o.Payload
	if err := producer.Produce(rw, payload); err != nil {
		panic(err) // let the recovery middleware deal with this
	}
}

// DownloadFileUnauthorizedCode is the HTTP code returned for type DownloadFileUnauthorized
const DownloadFileUnauthorizedCode int = 401

/*
DownloadFileUnauthorized User is not authenticated

swagger:response downloadFileUnauthorized
*/
type DownloadFileUnauthorized struct {

	/*
	  In: Body
	*/
	Payload *models.Errors `json:"body,omitempty"`
}

// NewDownloadFileUnauthorized creates DownloadFileUnauthorized with default headers values
func NewDownloadFileUnauthorized() *DownloadFileUnauthorized {

	return &DownloadFileUnauthorized{}
}

// WithPayload adds the payload to the download file unauthorized response
func (o *DownloadFileUnauthorized) WithPayload(payload *models.Errors) *DownloadFileUnauthorized {
	o.Payload = payload
	return o
}

// SetPayload sets the payload to the download file unauthorized response
func (o *DownloadFileUnauthorized) SetPayload(payload *models.Errors) {
	o.Payload = payload
}

// WriteResponse to the client
func (o *DownloadFileUnauthorized) WriteResponse(rw http.ResponseWriter, producer runtime.Producer) {

	rw.WriteHeader(401)
	if o.Payload != nil {
		payload := o.Payload
		if err := producer.Produce(rw, payload); err != nil {
			panic(err) // let the recovery middleware deal with this
		}
	}
}

// DownloadFileForbiddenCode is the HTTP code returned for type DownloadFileForbidden
const DownloadFileForbiddenCode int = 403

/*
DownloadFileForbidden User is not authorized for request

swagger:response downloadFileForbidden
*/
type DownloadFileForbidden struct {

	/*
	  In: Body
	*/
	Payload *models.Errors `json:"body,omitempty"`
}

// NewDownloadFileForbidden creates DownloadFileForbidden with default headers values
func NewDownloadFileForbidden() *DownloadFileForbidden {

	return &DownloadFileForbidden{}
}

// WithPayload adds the payload to the download file forbidden response
func (o *DownloadFileForbidden) WithPayload(payload *models.Errors) *DownloadFileForbidden {
	o.Payload = payload
	return o
}

// SetPayload sets the payload to the download file forbidden response
func (o *DownloadFileForbidden) SetPayload(payload *models.Errors) {
	o.Payload = payload
}

// WriteResponse to the client
func (o *DownloadFileForbidden) WriteResponse(rw http.ResponseWriter, producer runtime.Producer) {

	rw.WriteHeader(403)
	if o.Payload != nil {
		payload := o.Payload
		if err := producer.Produce(rw, payload); err != nil {
			panic(err) // let the recovery middleware deal with this
		}
	}
}

// DownloadFileNotFoundCode is the HTTP code returned for type DownloadFileNotFound
const DownloadFileNotFoundCode int = 404

/*
DownloadFileNotFound File not found

swagger:response downloadFileNotFound
*/
type DownloadFileNotFound struct {

	/*
	  In: Body
	*/
	Payload *models.Errors `json:"body,omitempty"`
}

// NewDownloadFileNotFound creates DownloadFileNotFound with default headers values
func NewDownloadFileNotFound() *DownloadFileNotFound {

	return &DownloadFileNotFound{}
}

// WithPayload adds the payload to the download file not found response
func (o *DownloadFileNotFound) WithPayload(payload *models.Errors) *DownloadFileNotFound {
	o.Payload = payload
	return o
}

// SetPayload sets the payload to the download file not found response
func (o *DownloadFileNotFound) SetPayload(payload *models.Errors) {
	o.Payload = payload
}

// WriteResponse to the client
func (o *DownloadFileNotFound) WriteResponse(rw http.ResponseWriter, producer runtime.Producer) {

	rw.WriteHeader(404)
	if o.Payload != nil {
		payload := o.Payload
		if err := producer.Produce(rw, payload); err != nil {
			panic(err) // let the recovery middleware deal with this
		}
	}
}

// DownloadFileNotAcceptableCode is the HTTP code returned for type DownloadFileNotAcceptable
const DownloadFileNotAcceptableCode int = 406

/*
DownloadFileNotAcceptable The resource cannot be represented in the format that would be acceptable to the user agent

swagger:response downloadFileNotAcceptable
*/
type DownloadFileNotAcceptable struct {

	/*
	  In: Body
	*/
	Payload *models.Errors `json:"body,omitempty"`
}

// NewDownloadFileNotAcceptable creates DownloadFileNotAcceptable with default headers values
func NewDownloadFileNotAcceptable() *DownloadFileNotAcceptable {

	return &DownloadFileNotAcceptable{}
}

// WithPayload adds the payload to the download file not acceptable response
func (o *DownloadFileNotAcceptable) WithPayload(payload *models.Errors) *DownloadFileNotAcceptable {
	o.Payload = payload
	return o
}

// SetPayload sets the payload to the download file not acceptable response
func (o *DownloadFileNotAcceptable) SetPayload(payload *models.Errors) {
	o.Payload = payload
}

// WriteResponse to the client
func (o *DownloadFileNotAcceptable) WriteResponse(rw http.ResponseWriter, producer runtime.Producer) {

	rw.WriteHeader(406)
	if o.Payload != nil {
		payload := o.Payload
		if err := producer.Produce(rw, payload); err != nil {
			panic(err) // let the recovery middleware deal with this
		}
	}
}

// DownloadFileInternalServerErrorCode is the HTTP code returned for type DownloadFileInternalServerError
const DownloadFileInternalServerErrorCode int = 500

/*
DownloadFileInternalServerError Server error, for more information see errorcode and message

swagger:response downloadFileInternalServerError
*/
type DownloadFileInternalServerError struct {

	/*
	  In: Body
	*/
	Payload *models.Errors `json:"body,omitempty"`
}

// NewDownloadFileInternalServerError creates DownloadFileInternalServerError with default headers values
func NewDownloadFileInternalServerError() *DownloadFileInternalServerError {

	return &DownloadFileInternalServerError{}
}

// WithPayload adds the payload to the download file internal server error response
func (o *DownloadFileInternalServerError) WithPayload(payload *models.Errors) *DownloadFileInternalServerError {
	o.Payload = payload
	return o
}

// SetPayload sets the payload to the download file internal server error response
func (o *DownloadFileInternalServerError) SetPayload(payload *models.Errors) {
	o.Payload = payload
}

// WriteResponse to the client
func (o *DownloadFileInternalServerError) WriteResponse(rw http.ResponseWriter, producer runtime.Producer) {

	rw.WriteHeader(500)
	if o.Payload != nil {
		payload := o.Payload
		if err := producer.Produce(rw, payload); err != nil {
			panic(err) // let the recovery middleware deal with this
		}
	}
}
