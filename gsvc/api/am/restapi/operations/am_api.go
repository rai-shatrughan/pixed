// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"
	"io"
	"net/http"
	"strings"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/loads"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/runtime/middleware"
	"github.com/go-openapi/runtime/security"
	"github.com/go-openapi/spec"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"

	"gsvc/api/am/models"
	"gsvc/api/am/restapi/operations/aspecttype"
	"gsvc/api/am/restapi/operations/assetmodellock"
	"gsvc/api/am/restapi/operations/assets"
	"gsvc/api/am/restapi/operations/assettype"
	"gsvc/api/am/restapi/operations/billboard"
	"gsvc/api/am/restapi/operations/files"
	"gsvc/api/am/restapi/operations/locations"
	"gsvc/api/am/restapi/operations/structure"
)

// NewAmAPI creates a new Am instance
func NewAmAPI(spec *loads.Document) *AmAPI {
	return &AmAPI{
		handlers:            make(map[string]map[string]http.Handler),
		formats:             strfmt.Default,
		defaultConsumes:     "application/json",
		defaultProduces:     "application/json",
		customConsumers:     make(map[string]runtime.Consumer),
		customProducers:     make(map[string]runtime.Producer),
		PreServerShutdown:   func() {},
		ServerShutdown:      func() {},
		spec:                spec,
		useSwaggerUI:        false,
		ServeError:          errors.ServeError,
		BasicAuthenticator:  security.BasicAuth,
		APIKeyAuthenticator: security.APIKeyAuth,
		BearerAuthenticator: security.BearerAuth,

		JSONConsumer:          runtime.JSONConsumer(),
		MultipartformConsumer: runtime.DiscardConsumer,

		ApplicationBase64Producer: runtime.ProducerFunc(func(w io.Writer, data interface{}) error {
			return errors.NotImplemented("applicationBase64 producer has not yet been implemented")
		}),
		BinProducer:  runtime.ByteStreamProducer(),
		JSONProducer: runtime.JSONProducer(),

		AssetsAddAssetHandler: assets.AddAssetHandlerFunc(func(params assets.AddAssetParams, principal *models.Principal) middleware.Responder {
			return middleware.NotImplemented("operation assets.AddAsset has not yet been implemented")
		}),
		AspecttypeDeleteAspectTypeHandler: aspecttype.DeleteAspectTypeHandlerFunc(func(params aspecttype.DeleteAspectTypeParams, principal *models.Principal) middleware.Responder {
			return middleware.NotImplemented("operation aspecttype.DeleteAspectType has not yet been implemented")
		}),
		AssetsDeleteAssetHandler: assets.DeleteAssetHandlerFunc(func(params assets.DeleteAssetParams, principal *models.Principal) middleware.Responder {
			return middleware.NotImplemented("operation assets.DeleteAsset has not yet been implemented")
		}),
		AssetsDeleteAssetFileAssigmentHandler: assets.DeleteAssetFileAssigmentHandlerFunc(func(params assets.DeleteAssetFileAssigmentParams, principal *models.Principal) middleware.Responder {
			return middleware.NotImplemented("operation assets.DeleteAssetFileAssigment has not yet been implemented")
		}),
		LocationsDeleteAssetLocationHandler: locations.DeleteAssetLocationHandlerFunc(func(params locations.DeleteAssetLocationParams, principal *models.Principal) middleware.Responder {
			return middleware.NotImplemented("operation locations.DeleteAssetLocation has not yet been implemented")
		}),
		AssettypeDeleteAssetTypeHandler: assettype.DeleteAssetTypeHandlerFunc(func(params assettype.DeleteAssetTypeParams, principal *models.Principal) middleware.Responder {
			return middleware.NotImplemented("operation assettype.DeleteAssetType has not yet been implemented")
		}),
		AssettypeDeleteAssetTypeFileAssignmentHandler: assettype.DeleteAssetTypeFileAssignmentHandlerFunc(func(params assettype.DeleteAssetTypeFileAssignmentParams, principal *models.Principal) middleware.Responder {
			return middleware.NotImplemented("operation assettype.DeleteAssetTypeFileAssignment has not yet been implemented")
		}),
		FilesDeleteFileHandler: files.DeleteFileHandlerFunc(func(params files.DeleteFileParams, principal *models.Principal) middleware.Responder {
			return middleware.NotImplemented("operation files.DeleteFile has not yet been implemented")
		}),
		FilesDownloadFileHandler: files.DownloadFileHandlerFunc(func(params files.DownloadFileParams, principal *models.Principal) middleware.Responder {
			return middleware.NotImplemented("operation files.DownloadFile has not yet been implemented")
		}),
		AspecttypeGetAspectTypeHandler: aspecttype.GetAspectTypeHandlerFunc(func(params aspecttype.GetAspectTypeParams, principal *models.Principal) middleware.Responder {
			return middleware.NotImplemented("operation aspecttype.GetAspectType has not yet been implemented")
		}),
		AssetsGetAssetHandler: assets.GetAssetHandlerFunc(func(params assets.GetAssetParams, principal *models.Principal) middleware.Responder {
			return middleware.NotImplemented("operation assets.GetAsset has not yet been implemented")
		}),
		AssetmodellockGetAssetModelLockHandler: assetmodellock.GetAssetModelLockHandlerFunc(func(params assetmodellock.GetAssetModelLockParams, principal *models.Principal) middleware.Responder {
			return middleware.NotImplemented("operation assetmodellock.GetAssetModelLock has not yet been implemented")
		}),
		AssettypeGetAssetTypeHandler: assettype.GetAssetTypeHandlerFunc(func(params assettype.GetAssetTypeParams, principal *models.Principal) middleware.Responder {
			return middleware.NotImplemented("operation assettype.GetAssetType has not yet been implemented")
		}),
		BillboardGetBillboardHandler: billboard.GetBillboardHandlerFunc(func(params billboard.GetBillboardParams, principal *models.Principal) middleware.Responder {
			return middleware.NotImplemented("operation billboard.GetBillboard has not yet been implemented")
		}),
		FilesGetFileHandler: files.GetFileHandlerFunc(func(params files.GetFileParams, principal *models.Principal) middleware.Responder {
			return middleware.NotImplemented("operation files.GetFile has not yet been implemented")
		}),
		AssetsGetRootAssetHandler: assets.GetRootAssetHandlerFunc(func(params assets.GetRootAssetParams, principal *models.Principal) middleware.Responder {
			return middleware.NotImplemented("operation assets.GetRootAsset has not yet been implemented")
		}),
		AspecttypeListAspectTypesHandler: aspecttype.ListAspectTypesHandlerFunc(func(params aspecttype.ListAspectTypesParams, principal *models.Principal) middleware.Responder {
			return middleware.NotImplemented("operation aspecttype.ListAspectTypes has not yet been implemented")
		}),
		StructureListAssetAspectsHandler: structure.ListAssetAspectsHandlerFunc(func(params structure.ListAssetAspectsParams, principal *models.Principal) middleware.Responder {
			return middleware.NotImplemented("operation structure.ListAssetAspects has not yet been implemented")
		}),
		AssettypeListAssetTypesHandler: assettype.ListAssetTypesHandlerFunc(func(params assettype.ListAssetTypesParams, principal *models.Principal) middleware.Responder {
			return middleware.NotImplemented("operation assettype.ListAssetTypes has not yet been implemented")
		}),
		StructureListAssetVariablesHandler: structure.ListAssetVariablesHandlerFunc(func(params structure.ListAssetVariablesParams, principal *models.Principal) middleware.Responder {
			return middleware.NotImplemented("operation structure.ListAssetVariables has not yet been implemented")
		}),
		AssetsListAssetsHandler: assets.ListAssetsHandlerFunc(func(params assets.ListAssetsParams, principal *models.Principal) middleware.Responder {
			return middleware.NotImplemented("operation assets.ListAssets has not yet been implemented")
		}),
		FilesListFilesHandler: files.ListFilesHandlerFunc(func(params files.ListFilesParams, principal *models.Principal) middleware.Responder {
			return middleware.NotImplemented("operation files.ListFiles has not yet been implemented")
		}),
		AssetsMoveAssetHandler: assets.MoveAssetHandlerFunc(func(params assets.MoveAssetParams, principal *models.Principal) middleware.Responder {
			return middleware.NotImplemented("operation assets.MoveAsset has not yet been implemented")
		}),
		AssetmodellockPutAssetModelLockHandler: assetmodellock.PutAssetModelLockHandlerFunc(func(params assetmodellock.PutAssetModelLockParams, principal *models.Principal) middleware.Responder {
			return middleware.NotImplemented("operation assetmodellock.PutAssetModelLock has not yet been implemented")
		}),
		AssetsReplaceAssetHandler: assets.ReplaceAssetHandlerFunc(func(params assets.ReplaceAssetParams, principal *models.Principal) middleware.Responder {
			return middleware.NotImplemented("operation assets.ReplaceAsset has not yet been implemented")
		}),
		FilesReplaceFileHandler: files.ReplaceFileHandlerFunc(func(params files.ReplaceFileParams, principal *models.Principal) middleware.Responder {
			return middleware.NotImplemented("operation files.ReplaceFile has not yet been implemented")
		}),
		AspecttypeSaveAspectTypeHandler: aspecttype.SaveAspectTypeHandlerFunc(func(params aspecttype.SaveAspectTypeParams, principal *models.Principal) middleware.Responder {
			return middleware.NotImplemented("operation aspecttype.SaveAspectType has not yet been implemented")
		}),
		AssetsSaveAssetFileAssignmentHandler: assets.SaveAssetFileAssignmentHandlerFunc(func(params assets.SaveAssetFileAssignmentParams, principal *models.Principal) middleware.Responder {
			return middleware.NotImplemented("operation assets.SaveAssetFileAssignment has not yet been implemented")
		}),
		LocationsSaveAssetLocationHandler: locations.SaveAssetLocationHandlerFunc(func(params locations.SaveAssetLocationParams, principal *models.Principal) middleware.Responder {
			return middleware.NotImplemented("operation locations.SaveAssetLocation has not yet been implemented")
		}),
		AssettypeSaveAssetTypeHandler: assettype.SaveAssetTypeHandlerFunc(func(params assettype.SaveAssetTypeParams, principal *models.Principal) middleware.Responder {
			return middleware.NotImplemented("operation assettype.SaveAssetType has not yet been implemented")
		}),
		AssettypeSaveAssetTypeFileAssignmentHandler: assettype.SaveAssetTypeFileAssignmentHandlerFunc(func(params assettype.SaveAssetTypeFileAssignmentParams, principal *models.Principal) middleware.Responder {
			return middleware.NotImplemented("operation assettype.SaveAssetTypeFileAssignment has not yet been implemented")
		}),
		AspecttypeUpdateAspectTypeHandler: aspecttype.UpdateAspectTypeHandlerFunc(func(params aspecttype.UpdateAspectTypeParams, principal *models.Principal) middleware.Responder {
			return middleware.NotImplemented("operation aspecttype.UpdateAspectType has not yet been implemented")
		}),
		AspecttypeUpdateAspectTypeVariableHandler: aspecttype.UpdateAspectTypeVariableHandlerFunc(func(params aspecttype.UpdateAspectTypeVariableParams, principal *models.Principal) middleware.Responder {
			return middleware.NotImplemented("operation aspecttype.UpdateAspectTypeVariable has not yet been implemented")
		}),
		AssetsUpdateAssetHandler: assets.UpdateAssetHandlerFunc(func(params assets.UpdateAssetParams, principal *models.Principal) middleware.Responder {
			return middleware.NotImplemented("operation assets.UpdateAsset has not yet been implemented")
		}),
		AssettypeUpdateAssetTypeHandler: assettype.UpdateAssetTypeHandlerFunc(func(params assettype.UpdateAssetTypeParams, principal *models.Principal) middleware.Responder {
			return middleware.NotImplemented("operation assettype.UpdateAssetType has not yet been implemented")
		}),
		AssettypeUpdateAssetTypeVariableHandler: assettype.UpdateAssetTypeVariableHandlerFunc(func(params assettype.UpdateAssetTypeVariableParams, principal *models.Principal) middleware.Responder {
			return middleware.NotImplemented("operation assettype.UpdateAssetTypeVariable has not yet been implemented")
		}),
		FilesUploadFileHandler: files.UploadFileHandlerFunc(func(params files.UploadFileParams, principal *models.Principal) middleware.Responder {
			return middleware.NotImplemented("operation files.UploadFile has not yet been implemented")
		}),

		AspecttypeAuth: func(token string, scopes []string) (*models.Principal, error) {
			return nil, errors.NotImplemented("oauth2 bearer auth (aspecttype) has not yet been implemented")
		},
		AssetAuth: func(token string, scopes []string) (*models.Principal, error) {
			return nil, errors.NotImplemented("oauth2 bearer auth (asset) has not yet been implemented")
		},
		AssetmodelAuth: func(token string, scopes []string) (*models.Principal, error) {
			return nil, errors.NotImplemented("oauth2 bearer auth (assetmodel) has not yet been implemented")
		},
		AssettypeAuth: func(token string, scopes []string) (*models.Principal, error) {
			return nil, errors.NotImplemented("oauth2 bearer auth (assettype) has not yet been implemented")
		},
		FileAuth: func(token string, scopes []string) (*models.Principal, error) {
			return nil, errors.NotImplemented("oauth2 bearer auth (file) has not yet been implemented")
		},
		LocationAuth: func(token string, scopes []string) (*models.Principal, error) {
			return nil, errors.NotImplemented("oauth2 bearer auth (location) has not yet been implemented")
		},
		// default authorizer is authorized meaning no requests are blocked
		APIAuthorizer: security.Authorized(),
	}
}

/*AmAPI Service for configuring, reading and managing assets, asset types and aspect types. */
type AmAPI struct {
	spec            *loads.Document
	context         *middleware.Context
	handlers        map[string]map[string]http.Handler
	formats         strfmt.Registry
	customConsumers map[string]runtime.Consumer
	customProducers map[string]runtime.Producer
	defaultConsumes string
	defaultProduces string
	Middleware      func(middleware.Builder) http.Handler
	useSwaggerUI    bool

	// BasicAuthenticator generates a runtime.Authenticator from the supplied basic auth function.
	// It has a default implementation in the security package, however you can replace it for your particular usage.
	BasicAuthenticator func(security.UserPassAuthentication) runtime.Authenticator

	// APIKeyAuthenticator generates a runtime.Authenticator from the supplied token auth function.
	// It has a default implementation in the security package, however you can replace it for your particular usage.
	APIKeyAuthenticator func(string, string, security.TokenAuthentication) runtime.Authenticator

	// BearerAuthenticator generates a runtime.Authenticator from the supplied bearer token auth function.
	// It has a default implementation in the security package, however you can replace it for your particular usage.
	BearerAuthenticator func(string, security.ScopedTokenAuthentication) runtime.Authenticator

	// JSONConsumer registers a consumer for the following mime types:
	//   - application/json
	//   - application/merge-patch+json
	JSONConsumer runtime.Consumer
	// MultipartformConsumer registers a consumer for the following mime types:
	//   - multipart/form-data
	MultipartformConsumer runtime.Consumer

	// ApplicationBase64Producer registers a producer for the following mime types:
	//   - application/base64
	ApplicationBase64Producer runtime.Producer
	// BinProducer registers a producer for the following mime types:
	//   - application/octet-stream
	BinProducer runtime.Producer
	// JSONProducer registers a producer for the following mime types:
	//   - application/hal+json
	//   - application/vnd.error+json
	JSONProducer runtime.Producer

	// AspecttypeAuth registers a function that takes an access token and a collection of required scopes and returns a principal
	// it performs authentication based on an oauth2 bearer token provided in the request
	AspecttypeAuth func(string, []string) (*models.Principal, error)

	// AssetAuth registers a function that takes an access token and a collection of required scopes and returns a principal
	// it performs authentication based on an oauth2 bearer token provided in the request
	AssetAuth func(string, []string) (*models.Principal, error)

	// AssetmodelAuth registers a function that takes an access token and a collection of required scopes and returns a principal
	// it performs authentication based on an oauth2 bearer token provided in the request
	AssetmodelAuth func(string, []string) (*models.Principal, error)

	// AssettypeAuth registers a function that takes an access token and a collection of required scopes and returns a principal
	// it performs authentication based on an oauth2 bearer token provided in the request
	AssettypeAuth func(string, []string) (*models.Principal, error)

	// FileAuth registers a function that takes an access token and a collection of required scopes and returns a principal
	// it performs authentication based on an oauth2 bearer token provided in the request
	FileAuth func(string, []string) (*models.Principal, error)

	// LocationAuth registers a function that takes an access token and a collection of required scopes and returns a principal
	// it performs authentication based on an oauth2 bearer token provided in the request
	LocationAuth func(string, []string) (*models.Principal, error)

	// APIAuthorizer provides access control (ACL/RBAC/ABAC) by providing access to the request and authenticated principal
	APIAuthorizer runtime.Authorizer

	// AssetsAddAssetHandler sets the operation handler for the add asset operation
	AssetsAddAssetHandler assets.AddAssetHandler
	// AspecttypeDeleteAspectTypeHandler sets the operation handler for the delete aspect type operation
	AspecttypeDeleteAspectTypeHandler aspecttype.DeleteAspectTypeHandler
	// AssetsDeleteAssetHandler sets the operation handler for the delete asset operation
	AssetsDeleteAssetHandler assets.DeleteAssetHandler
	// AssetsDeleteAssetFileAssigmentHandler sets the operation handler for the delete asset file assigment operation
	AssetsDeleteAssetFileAssigmentHandler assets.DeleteAssetFileAssigmentHandler
	// LocationsDeleteAssetLocationHandler sets the operation handler for the delete asset location operation
	LocationsDeleteAssetLocationHandler locations.DeleteAssetLocationHandler
	// AssettypeDeleteAssetTypeHandler sets the operation handler for the delete asset type operation
	AssettypeDeleteAssetTypeHandler assettype.DeleteAssetTypeHandler
	// AssettypeDeleteAssetTypeFileAssignmentHandler sets the operation handler for the delete asset type file assignment operation
	AssettypeDeleteAssetTypeFileAssignmentHandler assettype.DeleteAssetTypeFileAssignmentHandler
	// FilesDeleteFileHandler sets the operation handler for the delete file operation
	FilesDeleteFileHandler files.DeleteFileHandler
	// FilesDownloadFileHandler sets the operation handler for the download file operation
	FilesDownloadFileHandler files.DownloadFileHandler
	// AspecttypeGetAspectTypeHandler sets the operation handler for the get aspect type operation
	AspecttypeGetAspectTypeHandler aspecttype.GetAspectTypeHandler
	// AssetsGetAssetHandler sets the operation handler for the get asset operation
	AssetsGetAssetHandler assets.GetAssetHandler
	// AssetmodellockGetAssetModelLockHandler sets the operation handler for the get asset model lock operation
	AssetmodellockGetAssetModelLockHandler assetmodellock.GetAssetModelLockHandler
	// AssettypeGetAssetTypeHandler sets the operation handler for the get asset type operation
	AssettypeGetAssetTypeHandler assettype.GetAssetTypeHandler
	// BillboardGetBillboardHandler sets the operation handler for the get billboard operation
	BillboardGetBillboardHandler billboard.GetBillboardHandler
	// FilesGetFileHandler sets the operation handler for the get file operation
	FilesGetFileHandler files.GetFileHandler
	// AssetsGetRootAssetHandler sets the operation handler for the get root asset operation
	AssetsGetRootAssetHandler assets.GetRootAssetHandler
	// AspecttypeListAspectTypesHandler sets the operation handler for the list aspect types operation
	AspecttypeListAspectTypesHandler aspecttype.ListAspectTypesHandler
	// StructureListAssetAspectsHandler sets the operation handler for the list asset aspects operation
	StructureListAssetAspectsHandler structure.ListAssetAspectsHandler
	// AssettypeListAssetTypesHandler sets the operation handler for the list asset types operation
	AssettypeListAssetTypesHandler assettype.ListAssetTypesHandler
	// StructureListAssetVariablesHandler sets the operation handler for the list asset variables operation
	StructureListAssetVariablesHandler structure.ListAssetVariablesHandler
	// AssetsListAssetsHandler sets the operation handler for the list assets operation
	AssetsListAssetsHandler assets.ListAssetsHandler
	// FilesListFilesHandler sets the operation handler for the list files operation
	FilesListFilesHandler files.ListFilesHandler
	// AssetsMoveAssetHandler sets the operation handler for the move asset operation
	AssetsMoveAssetHandler assets.MoveAssetHandler
	// AssetmodellockPutAssetModelLockHandler sets the operation handler for the put asset model lock operation
	AssetmodellockPutAssetModelLockHandler assetmodellock.PutAssetModelLockHandler
	// AssetsReplaceAssetHandler sets the operation handler for the replace asset operation
	AssetsReplaceAssetHandler assets.ReplaceAssetHandler
	// FilesReplaceFileHandler sets the operation handler for the replace file operation
	FilesReplaceFileHandler files.ReplaceFileHandler
	// AspecttypeSaveAspectTypeHandler sets the operation handler for the save aspect type operation
	AspecttypeSaveAspectTypeHandler aspecttype.SaveAspectTypeHandler
	// AssetsSaveAssetFileAssignmentHandler sets the operation handler for the save asset file assignment operation
	AssetsSaveAssetFileAssignmentHandler assets.SaveAssetFileAssignmentHandler
	// LocationsSaveAssetLocationHandler sets the operation handler for the save asset location operation
	LocationsSaveAssetLocationHandler locations.SaveAssetLocationHandler
	// AssettypeSaveAssetTypeHandler sets the operation handler for the save asset type operation
	AssettypeSaveAssetTypeHandler assettype.SaveAssetTypeHandler
	// AssettypeSaveAssetTypeFileAssignmentHandler sets the operation handler for the save asset type file assignment operation
	AssettypeSaveAssetTypeFileAssignmentHandler assettype.SaveAssetTypeFileAssignmentHandler
	// AspecttypeUpdateAspectTypeHandler sets the operation handler for the update aspect type operation
	AspecttypeUpdateAspectTypeHandler aspecttype.UpdateAspectTypeHandler
	// AspecttypeUpdateAspectTypeVariableHandler sets the operation handler for the update aspect type variable operation
	AspecttypeUpdateAspectTypeVariableHandler aspecttype.UpdateAspectTypeVariableHandler
	// AssetsUpdateAssetHandler sets the operation handler for the update asset operation
	AssetsUpdateAssetHandler assets.UpdateAssetHandler
	// AssettypeUpdateAssetTypeHandler sets the operation handler for the update asset type operation
	AssettypeUpdateAssetTypeHandler assettype.UpdateAssetTypeHandler
	// AssettypeUpdateAssetTypeVariableHandler sets the operation handler for the update asset type variable operation
	AssettypeUpdateAssetTypeVariableHandler assettype.UpdateAssetTypeVariableHandler
	// FilesUploadFileHandler sets the operation handler for the upload file operation
	FilesUploadFileHandler files.UploadFileHandler

	// ServeError is called when an error is received, there is a default handler
	// but you can set your own with this
	ServeError func(http.ResponseWriter, *http.Request, error)

	// PreServerShutdown is called before the HTTP(S) server is shutdown
	// This allows for custom functions to get executed before the HTTP(S) server stops accepting traffic
	PreServerShutdown func()

	// ServerShutdown is called when the HTTP(S) server is shut down and done
	// handling all active connections and does not accept connections any more
	ServerShutdown func()

	// Custom command line argument groups with their descriptions
	CommandLineOptionsGroups []swag.CommandLineOptionsGroup

	// User defined logger function.
	Logger func(string, ...interface{})
}

// UseRedoc for documentation at /docs
func (o *AmAPI) UseRedoc() {
	o.useSwaggerUI = false
}

// UseSwaggerUI for documentation at /docs
func (o *AmAPI) UseSwaggerUI() {
	o.useSwaggerUI = true
}

// SetDefaultProduces sets the default produces media type
func (o *AmAPI) SetDefaultProduces(mediaType string) {
	o.defaultProduces = mediaType
}

// SetDefaultConsumes returns the default consumes media type
func (o *AmAPI) SetDefaultConsumes(mediaType string) {
	o.defaultConsumes = mediaType
}

// SetSpec sets a spec that will be served for the clients.
func (o *AmAPI) SetSpec(spec *loads.Document) {
	o.spec = spec
}

// DefaultProduces returns the default produces media type
func (o *AmAPI) DefaultProduces() string {
	return o.defaultProduces
}

// DefaultConsumes returns the default consumes media type
func (o *AmAPI) DefaultConsumes() string {
	return o.defaultConsumes
}

// Formats returns the registered string formats
func (o *AmAPI) Formats() strfmt.Registry {
	return o.formats
}

// RegisterFormat registers a custom format validator
func (o *AmAPI) RegisterFormat(name string, format strfmt.Format, validator strfmt.Validator) {
	o.formats.Add(name, format, validator)
}

// Validate validates the registrations in the AmAPI
func (o *AmAPI) Validate() error {
	var unregistered []string

	if o.JSONConsumer == nil {
		unregistered = append(unregistered, "JSONConsumer")
	}
	if o.MultipartformConsumer == nil {
		unregistered = append(unregistered, "MultipartformConsumer")
	}

	if o.ApplicationBase64Producer == nil {
		unregistered = append(unregistered, "ApplicationBase64Producer")
	}
	if o.BinProducer == nil {
		unregistered = append(unregistered, "BinProducer")
	}
	if o.JSONProducer == nil {
		unregistered = append(unregistered, "JSONProducer")
	}

	if o.AspecttypeAuth == nil {
		unregistered = append(unregistered, "AspecttypeAuth")
	}
	if o.AssetAuth == nil {
		unregistered = append(unregistered, "AssetAuth")
	}
	if o.AssetmodelAuth == nil {
		unregistered = append(unregistered, "AssetmodelAuth")
	}
	if o.AssettypeAuth == nil {
		unregistered = append(unregistered, "AssettypeAuth")
	}
	if o.FileAuth == nil {
		unregistered = append(unregistered, "FileAuth")
	}
	if o.LocationAuth == nil {
		unregistered = append(unregistered, "LocationAuth")
	}

	if o.AssetsAddAssetHandler == nil {
		unregistered = append(unregistered, "assets.AddAssetHandler")
	}
	if o.AspecttypeDeleteAspectTypeHandler == nil {
		unregistered = append(unregistered, "aspecttype.DeleteAspectTypeHandler")
	}
	if o.AssetsDeleteAssetHandler == nil {
		unregistered = append(unregistered, "assets.DeleteAssetHandler")
	}
	if o.AssetsDeleteAssetFileAssigmentHandler == nil {
		unregistered = append(unregistered, "assets.DeleteAssetFileAssigmentHandler")
	}
	if o.LocationsDeleteAssetLocationHandler == nil {
		unregistered = append(unregistered, "locations.DeleteAssetLocationHandler")
	}
	if o.AssettypeDeleteAssetTypeHandler == nil {
		unregistered = append(unregistered, "assettype.DeleteAssetTypeHandler")
	}
	if o.AssettypeDeleteAssetTypeFileAssignmentHandler == nil {
		unregistered = append(unregistered, "assettype.DeleteAssetTypeFileAssignmentHandler")
	}
	if o.FilesDeleteFileHandler == nil {
		unregistered = append(unregistered, "files.DeleteFileHandler")
	}
	if o.FilesDownloadFileHandler == nil {
		unregistered = append(unregistered, "files.DownloadFileHandler")
	}
	if o.AspecttypeGetAspectTypeHandler == nil {
		unregistered = append(unregistered, "aspecttype.GetAspectTypeHandler")
	}
	if o.AssetsGetAssetHandler == nil {
		unregistered = append(unregistered, "assets.GetAssetHandler")
	}
	if o.AssetmodellockGetAssetModelLockHandler == nil {
		unregistered = append(unregistered, "assetmodellock.GetAssetModelLockHandler")
	}
	if o.AssettypeGetAssetTypeHandler == nil {
		unregistered = append(unregistered, "assettype.GetAssetTypeHandler")
	}
	if o.BillboardGetBillboardHandler == nil {
		unregistered = append(unregistered, "billboard.GetBillboardHandler")
	}
	if o.FilesGetFileHandler == nil {
		unregistered = append(unregistered, "files.GetFileHandler")
	}
	if o.AssetsGetRootAssetHandler == nil {
		unregistered = append(unregistered, "assets.GetRootAssetHandler")
	}
	if o.AspecttypeListAspectTypesHandler == nil {
		unregistered = append(unregistered, "aspecttype.ListAspectTypesHandler")
	}
	if o.StructureListAssetAspectsHandler == nil {
		unregistered = append(unregistered, "structure.ListAssetAspectsHandler")
	}
	if o.AssettypeListAssetTypesHandler == nil {
		unregistered = append(unregistered, "assettype.ListAssetTypesHandler")
	}
	if o.StructureListAssetVariablesHandler == nil {
		unregistered = append(unregistered, "structure.ListAssetVariablesHandler")
	}
	if o.AssetsListAssetsHandler == nil {
		unregistered = append(unregistered, "assets.ListAssetsHandler")
	}
	if o.FilesListFilesHandler == nil {
		unregistered = append(unregistered, "files.ListFilesHandler")
	}
	if o.AssetsMoveAssetHandler == nil {
		unregistered = append(unregistered, "assets.MoveAssetHandler")
	}
	if o.AssetmodellockPutAssetModelLockHandler == nil {
		unregistered = append(unregistered, "assetmodellock.PutAssetModelLockHandler")
	}
	if o.AssetsReplaceAssetHandler == nil {
		unregistered = append(unregistered, "assets.ReplaceAssetHandler")
	}
	if o.FilesReplaceFileHandler == nil {
		unregistered = append(unregistered, "files.ReplaceFileHandler")
	}
	if o.AspecttypeSaveAspectTypeHandler == nil {
		unregistered = append(unregistered, "aspecttype.SaveAspectTypeHandler")
	}
	if o.AssetsSaveAssetFileAssignmentHandler == nil {
		unregistered = append(unregistered, "assets.SaveAssetFileAssignmentHandler")
	}
	if o.LocationsSaveAssetLocationHandler == nil {
		unregistered = append(unregistered, "locations.SaveAssetLocationHandler")
	}
	if o.AssettypeSaveAssetTypeHandler == nil {
		unregistered = append(unregistered, "assettype.SaveAssetTypeHandler")
	}
	if o.AssettypeSaveAssetTypeFileAssignmentHandler == nil {
		unregistered = append(unregistered, "assettype.SaveAssetTypeFileAssignmentHandler")
	}
	if o.AspecttypeUpdateAspectTypeHandler == nil {
		unregistered = append(unregistered, "aspecttype.UpdateAspectTypeHandler")
	}
	if o.AspecttypeUpdateAspectTypeVariableHandler == nil {
		unregistered = append(unregistered, "aspecttype.UpdateAspectTypeVariableHandler")
	}
	if o.AssetsUpdateAssetHandler == nil {
		unregistered = append(unregistered, "assets.UpdateAssetHandler")
	}
	if o.AssettypeUpdateAssetTypeHandler == nil {
		unregistered = append(unregistered, "assettype.UpdateAssetTypeHandler")
	}
	if o.AssettypeUpdateAssetTypeVariableHandler == nil {
		unregistered = append(unregistered, "assettype.UpdateAssetTypeVariableHandler")
	}
	if o.FilesUploadFileHandler == nil {
		unregistered = append(unregistered, "files.UploadFileHandler")
	}

	if len(unregistered) > 0 {
		return fmt.Errorf("missing registration: %s", strings.Join(unregistered, ", "))
	}

	return nil
}

// ServeErrorFor gets a error handler for a given operation id
func (o *AmAPI) ServeErrorFor(operationID string) func(http.ResponseWriter, *http.Request, error) {
	return o.ServeError
}

// AuthenticatorsFor gets the authenticators for the specified security schemes
func (o *AmAPI) AuthenticatorsFor(schemes map[string]spec.SecurityScheme) map[string]runtime.Authenticator {
	result := make(map[string]runtime.Authenticator)
	for name := range schemes {
		switch name {
		case "aspecttype":
			result[name] = o.BearerAuthenticator(name, func(token string, scopes []string) (interface{}, error) {
				return o.AspecttypeAuth(token, scopes)
			})

		case "asset":
			result[name] = o.BearerAuthenticator(name, func(token string, scopes []string) (interface{}, error) {
				return o.AssetAuth(token, scopes)
			})

		case "assetmodel":
			result[name] = o.BearerAuthenticator(name, func(token string, scopes []string) (interface{}, error) {
				return o.AssetmodelAuth(token, scopes)
			})

		case "assettype":
			result[name] = o.BearerAuthenticator(name, func(token string, scopes []string) (interface{}, error) {
				return o.AssettypeAuth(token, scopes)
			})

		case "file":
			result[name] = o.BearerAuthenticator(name, func(token string, scopes []string) (interface{}, error) {
				return o.FileAuth(token, scopes)
			})

		case "location":
			result[name] = o.BearerAuthenticator(name, func(token string, scopes []string) (interface{}, error) {
				return o.LocationAuth(token, scopes)
			})

		}
	}
	return result
}

// Authorizer returns the registered authorizer
func (o *AmAPI) Authorizer() runtime.Authorizer {
	return o.APIAuthorizer
}

// ConsumersFor gets the consumers for the specified media types.
// MIME type parameters are ignored here.
func (o *AmAPI) ConsumersFor(mediaTypes []string) map[string]runtime.Consumer {
	result := make(map[string]runtime.Consumer, len(mediaTypes))
	for _, mt := range mediaTypes {
		switch mt {
		case "application/json":
			result["application/json"] = o.JSONConsumer
		case "application/merge-patch+json":
			result["application/merge-patch+json"] = o.JSONConsumer
		case "multipart/form-data":
			result["multipart/form-data"] = o.MultipartformConsumer
		}

		if c, ok := o.customConsumers[mt]; ok {
			result[mt] = c
		}
	}
	return result
}

// ProducersFor gets the producers for the specified media types.
// MIME type parameters are ignored here.
func (o *AmAPI) ProducersFor(mediaTypes []string) map[string]runtime.Producer {
	result := make(map[string]runtime.Producer, len(mediaTypes))
	for _, mt := range mediaTypes {
		switch mt {
		case "application/base64":
			result["application/base64"] = o.ApplicationBase64Producer
		case "application/octet-stream":
			result["application/octet-stream"] = o.BinProducer
		case "application/hal+json":
			result["application/hal+json"] = o.JSONProducer
		case "application/vnd.error+json":
			result["application/vnd.error+json"] = o.JSONProducer
		}

		if p, ok := o.customProducers[mt]; ok {
			result[mt] = p
		}
	}
	return result
}

// HandlerFor gets a http.Handler for the provided operation method and path
func (o *AmAPI) HandlerFor(method, path string) (http.Handler, bool) {
	if o.handlers == nil {
		return nil, false
	}
	um := strings.ToUpper(method)
	if _, ok := o.handlers[um]; !ok {
		return nil, false
	}
	if path == "/" {
		path = ""
	}
	h, ok := o.handlers[um][path]
	return h, ok
}

// Context returns the middleware context for the am API
func (o *AmAPI) Context() *middleware.Context {
	if o.context == nil {
		o.context = middleware.NewRoutableContext(o.spec, o, nil)
	}

	return o.context
}

func (o *AmAPI) initHandlerCache() {
	o.Context() // don't care about the result, just that the initialization happened
	if o.handlers == nil {
		o.handlers = make(map[string]map[string]http.Handler)
	}

	if o.handlers["POST"] == nil {
		o.handlers["POST"] = make(map[string]http.Handler)
	}
	o.handlers["POST"]["/assets"] = assets.NewAddAsset(o.context, o.AssetsAddAssetHandler)
	if o.handlers["DELETE"] == nil {
		o.handlers["DELETE"] = make(map[string]http.Handler)
	}
	o.handlers["DELETE"]["/aspecttypes/{id}"] = aspecttype.NewDeleteAspectType(o.context, o.AspecttypeDeleteAspectTypeHandler)
	if o.handlers["DELETE"] == nil {
		o.handlers["DELETE"] = make(map[string]http.Handler)
	}
	o.handlers["DELETE"]["/assets/{id}"] = assets.NewDeleteAsset(o.context, o.AssetsDeleteAssetHandler)
	if o.handlers["DELETE"] == nil {
		o.handlers["DELETE"] = make(map[string]http.Handler)
	}
	o.handlers["DELETE"]["/assets/{id}/fileAssignments/{key}"] = assets.NewDeleteAssetFileAssigment(o.context, o.AssetsDeleteAssetFileAssigmentHandler)
	if o.handlers["DELETE"] == nil {
		o.handlers["DELETE"] = make(map[string]http.Handler)
	}
	o.handlers["DELETE"]["/assets/{id}/location"] = locations.NewDeleteAssetLocation(o.context, o.LocationsDeleteAssetLocationHandler)
	if o.handlers["DELETE"] == nil {
		o.handlers["DELETE"] = make(map[string]http.Handler)
	}
	o.handlers["DELETE"]["/assettypes/{id}"] = assettype.NewDeleteAssetType(o.context, o.AssettypeDeleteAssetTypeHandler)
	if o.handlers["DELETE"] == nil {
		o.handlers["DELETE"] = make(map[string]http.Handler)
	}
	o.handlers["DELETE"]["/assettypes/{id}/fileAssignments/{key}"] = assettype.NewDeleteAssetTypeFileAssignment(o.context, o.AssettypeDeleteAssetTypeFileAssignmentHandler)
	if o.handlers["DELETE"] == nil {
		o.handlers["DELETE"] = make(map[string]http.Handler)
	}
	o.handlers["DELETE"]["/files/{fileId}"] = files.NewDeleteFile(o.context, o.FilesDeleteFileHandler)
	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/files/{fileId}/file"] = files.NewDownloadFile(o.context, o.FilesDownloadFileHandler)
	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/aspecttypes/{id}"] = aspecttype.NewGetAspectType(o.context, o.AspecttypeGetAspectTypeHandler)
	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/assets/{id}"] = assets.NewGetAsset(o.context, o.AssetsGetAssetHandler)
	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/model/lock"] = assetmodellock.NewGetAssetModelLock(o.context, o.AssetmodellockGetAssetModelLockHandler)
	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/assettypes/{id}"] = assettype.NewGetAssetType(o.context, o.AssettypeGetAssetTypeHandler)
	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"][""] = billboard.NewGetBillboard(o.context, o.BillboardGetBillboardHandler)
	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/files/{fileId}"] = files.NewGetFile(o.context, o.FilesGetFileHandler)
	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/assets/root"] = assets.NewGetRootAsset(o.context, o.AssetsGetRootAssetHandler)
	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/aspecttypes"] = aspecttype.NewListAspectTypes(o.context, o.AspecttypeListAspectTypesHandler)
	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/assets/{id}/aspects"] = structure.NewListAssetAspects(o.context, o.StructureListAssetAspectsHandler)
	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/assettypes"] = assettype.NewListAssetTypes(o.context, o.AssettypeListAssetTypesHandler)
	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/assets/{id}/variables"] = structure.NewListAssetVariables(o.context, o.StructureListAssetVariablesHandler)
	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/assets"] = assets.NewListAssets(o.context, o.AssetsListAssetsHandler)
	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/files"] = files.NewListFiles(o.context, o.FilesListFilesHandler)
	if o.handlers["POST"] == nil {
		o.handlers["POST"] = make(map[string]http.Handler)
	}
	o.handlers["POST"]["/assets/{id}/move"] = assets.NewMoveAsset(o.context, o.AssetsMoveAssetHandler)
	if o.handlers["PUT"] == nil {
		o.handlers["PUT"] = make(map[string]http.Handler)
	}
	o.handlers["PUT"]["/model/lock"] = assetmodellock.NewPutAssetModelLock(o.context, o.AssetmodellockPutAssetModelLockHandler)
	if o.handlers["PUT"] == nil {
		o.handlers["PUT"] = make(map[string]http.Handler)
	}
	o.handlers["PUT"]["/assets/{id}"] = assets.NewReplaceAsset(o.context, o.AssetsReplaceAssetHandler)
	if o.handlers["PUT"] == nil {
		o.handlers["PUT"] = make(map[string]http.Handler)
	}
	o.handlers["PUT"]["/files/{fileId}"] = files.NewReplaceFile(o.context, o.FilesReplaceFileHandler)
	if o.handlers["PUT"] == nil {
		o.handlers["PUT"] = make(map[string]http.Handler)
	}
	o.handlers["PUT"]["/aspecttypes/{id}"] = aspecttype.NewSaveAspectType(o.context, o.AspecttypeSaveAspectTypeHandler)
	if o.handlers["PUT"] == nil {
		o.handlers["PUT"] = make(map[string]http.Handler)
	}
	o.handlers["PUT"]["/assets/{id}/fileAssignments/{key}"] = assets.NewSaveAssetFileAssignment(o.context, o.AssetsSaveAssetFileAssignmentHandler)
	if o.handlers["PUT"] == nil {
		o.handlers["PUT"] = make(map[string]http.Handler)
	}
	o.handlers["PUT"]["/assets/{id}/location"] = locations.NewSaveAssetLocation(o.context, o.LocationsSaveAssetLocationHandler)
	if o.handlers["PUT"] == nil {
		o.handlers["PUT"] = make(map[string]http.Handler)
	}
	o.handlers["PUT"]["/assettypes/{id}"] = assettype.NewSaveAssetType(o.context, o.AssettypeSaveAssetTypeHandler)
	if o.handlers["PUT"] == nil {
		o.handlers["PUT"] = make(map[string]http.Handler)
	}
	o.handlers["PUT"]["/assettypes/{id}/fileAssignments/{key}"] = assettype.NewSaveAssetTypeFileAssignment(o.context, o.AssettypeSaveAssetTypeFileAssignmentHandler)
	if o.handlers["PATCH"] == nil {
		o.handlers["PATCH"] = make(map[string]http.Handler)
	}
	o.handlers["PATCH"]["/aspecttypes/{id}"] = aspecttype.NewUpdateAspectType(o.context, o.AspecttypeUpdateAspectTypeHandler)
	if o.handlers["PATCH"] == nil {
		o.handlers["PATCH"] = make(map[string]http.Handler)
	}
	o.handlers["PATCH"]["/aspecttypes/{id}/variables"] = aspecttype.NewUpdateAspectTypeVariable(o.context, o.AspecttypeUpdateAspectTypeVariableHandler)
	if o.handlers["PATCH"] == nil {
		o.handlers["PATCH"] = make(map[string]http.Handler)
	}
	o.handlers["PATCH"]["/assets/{id}"] = assets.NewUpdateAsset(o.context, o.AssetsUpdateAssetHandler)
	if o.handlers["PATCH"] == nil {
		o.handlers["PATCH"] = make(map[string]http.Handler)
	}
	o.handlers["PATCH"]["/assettypes/{id}"] = assettype.NewUpdateAssetType(o.context, o.AssettypeUpdateAssetTypeHandler)
	if o.handlers["PATCH"] == nil {
		o.handlers["PATCH"] = make(map[string]http.Handler)
	}
	o.handlers["PATCH"]["/assettypes/{id}/variables"] = assettype.NewUpdateAssetTypeVariable(o.context, o.AssettypeUpdateAssetTypeVariableHandler)
	if o.handlers["POST"] == nil {
		o.handlers["POST"] = make(map[string]http.Handler)
	}
	o.handlers["POST"]["/files"] = files.NewUploadFile(o.context, o.FilesUploadFileHandler)
}

// Serve creates a http handler to serve the API over HTTP
// can be used directly in http.ListenAndServe(":8000", api.Serve(nil))
func (o *AmAPI) Serve(builder middleware.Builder) http.Handler {
	o.Init()

	if o.Middleware != nil {
		return o.Middleware(builder)
	}
	if o.useSwaggerUI {
		return o.context.APIHandlerSwaggerUI(builder)
	}
	return o.context.APIHandler(builder)
}

// Init allows you to just initialize the handler cache, you can then recompose the middleware as you see fit
func (o *AmAPI) Init() {
	if len(o.handlers) == 0 {
		o.initHandlerCache()
	}
}

// RegisterConsumer allows you to add (or override) a consumer for a media type.
func (o *AmAPI) RegisterConsumer(mediaType string, consumer runtime.Consumer) {
	o.customConsumers[mediaType] = consumer
}

// RegisterProducer allows you to add (or override) a producer for a media type.
func (o *AmAPI) RegisterProducer(mediaType string, producer runtime.Producer) {
	o.customProducers[mediaType] = producer
}

// AddMiddlewareFor adds a http middleware to existing handler
func (o *AmAPI) AddMiddlewareFor(method, path string, builder middleware.Builder) {
	um := strings.ToUpper(method)
	if path == "/" {
		path = ""
	}
	o.Init()
	if h, ok := o.handlers[um][path]; ok {
		o.handlers[method][path] = builder(h)
	}
}
