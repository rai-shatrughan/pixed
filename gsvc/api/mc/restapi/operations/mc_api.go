// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"
	"io"
	"net/http"
	"strings"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/loads"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/runtime/middleware"
	"github.com/go-openapi/runtime/security"
	"github.com/go-openapi/spec"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"

	"gsvc/api/mc/models"
	"gsvc/api/mc/restapi/operations/diagnostic_activations"
	"gsvc/api/mc/restapi/operations/diagnostic_information"
	"gsvc/api/mc/restapi/operations/exchange"
	"gsvc/api/mc/restapi/operations/mappings"
	"gsvc/api/mc/restapi/operations/record_recovery"
)

// NewMcAPI creates a new Mc instance
func NewMcAPI(spec *loads.Document) *McAPI {
	return &McAPI{
		handlers:            make(map[string]map[string]http.Handler),
		formats:             strfmt.Default,
		defaultConsumes:     "application/json",
		defaultProduces:     "application/json",
		customConsumers:     make(map[string]runtime.Consumer),
		customProducers:     make(map[string]runtime.Producer),
		PreServerShutdown:   func() {},
		ServerShutdown:      func() {},
		spec:                spec,
		useSwaggerUI:        false,
		ServeError:          errors.ServeError,
		BasicAuthenticator:  security.BasicAuth,
		APIKeyAuthenticator: security.APIKeyAuth,
		BearerAuthenticator: security.BearerAuth,

		JSONConsumer: runtime.JSONConsumer(),
		MultipartMixedConsumer: runtime.ConsumerFunc(func(r io.Reader, target interface{}) error {
			return errors.NotImplemented("multipartMixed consumer has not yet been implemented")
		}),

		JSONProducer: runtime.JSONProducer(),

		MappingsDeleteDataPointMappingsIDHandler: mappings.DeleteDataPointMappingsIDHandlerFunc(func(params mappings.DeleteDataPointMappingsIDParams, principal *models.Principal) middleware.Responder {
			return middleware.NotImplemented("operation mappings.DeleteDataPointMappingsID has not yet been implemented")
		}),
		DiagnosticActivationsDeleteDiagnosticActivationsIDHandler: diagnostic_activations.DeleteDiagnosticActivationsIDHandlerFunc(func(params diagnostic_activations.DeleteDiagnosticActivationsIDParams, principal *models.Principal) middleware.Responder {
			return middleware.NotImplemented("operation diagnostic_activations.DeleteDiagnosticActivationsID has not yet been implemented")
		}),
		RecordRecoveryDeleteRecoverableRecordsIDHandler: record_recovery.DeleteRecoverableRecordsIDHandlerFunc(func(params record_recovery.DeleteRecoverableRecordsIDParams, principal *models.Principal) middleware.Responder {
			return middleware.NotImplemented("operation record_recovery.DeleteRecoverableRecordsID has not yet been implemented")
		}),
		MappingsGetDataPointMappingsHandler: mappings.GetDataPointMappingsHandlerFunc(func(params mappings.GetDataPointMappingsParams, principal *models.Principal) middleware.Responder {
			return middleware.NotImplemented("operation mappings.GetDataPointMappings has not yet been implemented")
		}),
		MappingsGetDataPointMappingsIDHandler: mappings.GetDataPointMappingsIDHandlerFunc(func(params mappings.GetDataPointMappingsIDParams, principal *models.Principal) middleware.Responder {
			return middleware.NotImplemented("operation mappings.GetDataPointMappingsID has not yet been implemented")
		}),
		DiagnosticActivationsGetDiagnosticActivationsHandler: diagnostic_activations.GetDiagnosticActivationsHandlerFunc(func(params diagnostic_activations.GetDiagnosticActivationsParams, principal *models.Principal) middleware.Responder {
			return middleware.NotImplemented("operation diagnostic_activations.GetDiagnosticActivations has not yet been implemented")
		}),
		DiagnosticActivationsGetDiagnosticActivationsIDHandler: diagnostic_activations.GetDiagnosticActivationsIDHandlerFunc(func(params diagnostic_activations.GetDiagnosticActivationsIDParams, principal *models.Principal) middleware.Responder {
			return middleware.NotImplemented("operation diagnostic_activations.GetDiagnosticActivationsID has not yet been implemented")
		}),
		DiagnosticActivationsGetDiagnosticActivationsIDMessagesHandler: diagnostic_activations.GetDiagnosticActivationsIDMessagesHandlerFunc(func(params diagnostic_activations.GetDiagnosticActivationsIDMessagesParams, principal *models.Principal) middleware.Responder {
			return middleware.NotImplemented("operation diagnostic_activations.GetDiagnosticActivationsIDMessages has not yet been implemented")
		}),
		DiagnosticInformationGetDiagnosticInformationHandler: diagnostic_information.GetDiagnosticInformationHandlerFunc(func(params diagnostic_information.GetDiagnosticInformationParams, principal *models.Principal) middleware.Responder {
			return middleware.NotImplemented("operation diagnostic_information.GetDiagnosticInformation has not yet been implemented")
		}),
		RecordRecoveryGetRecoverableRecordsHandler: record_recovery.GetRecoverableRecordsHandlerFunc(func(params record_recovery.GetRecoverableRecordsParams, principal *models.Principal) middleware.Responder {
			return middleware.NotImplemented("operation record_recovery.GetRecoverableRecords has not yet been implemented")
		}),
		RecordRecoveryGetRecoverableRecordsIDDownloadLinkHandler: record_recovery.GetRecoverableRecordsIDDownloadLinkHandlerFunc(func(params record_recovery.GetRecoverableRecordsIDDownloadLinkParams, principal *models.Principal) middleware.Responder {
			return middleware.NotImplemented("operation record_recovery.GetRecoverableRecordsIDDownloadLink has not yet been implemented")
		}),
		MappingsPostDataPointMappingsHandler: mappings.PostDataPointMappingsHandlerFunc(func(params mappings.PostDataPointMappingsParams, principal *models.Principal) middleware.Responder {
			return middleware.NotImplemented("operation mappings.PostDataPointMappings has not yet been implemented")
		}),
		DiagnosticActivationsPostDiagnosticActivationsHandler: diagnostic_activations.PostDiagnosticActivationsHandlerFunc(func(params diagnostic_activations.PostDiagnosticActivationsParams, principal *models.Principal) middleware.Responder {
			return middleware.NotImplemented("operation diagnostic_activations.PostDiagnosticActivations has not yet been implemented")
		}),
		ExchangePostExchangeHandler: exchange.PostExchangeHandlerFunc(func(params exchange.PostExchangeParams, principal *models.Principal) middleware.Responder {
			return middleware.NotImplemented("operation exchange.PostExchange has not yet been implemented")
		}),
		RecordRecoveryPostRecoverableRecordsIDReplayHandler: record_recovery.PostRecoverableRecordsIDReplayHandlerFunc(func(params record_recovery.PostRecoverableRecordsIDReplayParams, principal *models.Principal) middleware.Responder {
			return middleware.NotImplemented("operation record_recovery.PostRecoverableRecordsIDReplay has not yet been implemented")
		}),
		DiagnosticActivationsPutDiagnosticActivationsIDHandler: diagnostic_activations.PutDiagnosticActivationsIDHandlerFunc(func(params diagnostic_activations.PutDiagnosticActivationsIDParams, principal *models.Principal) middleware.Responder {
			return middleware.NotImplemented("operation diagnostic_activations.PutDiagnosticActivationsID has not yet been implemented")
		}),

		DiagnosticActivationsAuth: func(token string, scopes []string) (*models.Principal, error) {
			return nil, errors.NotImplemented("oauth2 bearer auth (diagnosticActivations) has not yet been implemented")
		},
		DiagnosticInformationAuth: func(token string, scopes []string) (*models.Principal, error) {
			return nil, errors.NotImplemented("oauth2 bearer auth (diagnosticInformation) has not yet been implemented")
		},
		ExchangeAuth: func(token string, scopes []string) (*models.Principal, error) {
			return nil, errors.NotImplemented("oauth2 bearer auth (exchange) has not yet been implemented")
		},
		MappingsAuth: func(token string, scopes []string) (*models.Principal, error) {
			return nil, errors.NotImplemented("oauth2 bearer auth (mappings) has not yet been implemented")
		},
		RecordRecoveryAuth: func(token string, scopes []string) (*models.Principal, error) {
			return nil, errors.NotImplemented("oauth2 bearer auth (recordRecovery) has not yet been implemented")
		},
		// default authorizer is authorized meaning no requests are blocked
		APIAuthorizer: security.Authorized(),
	}
}

/*
McAPI
MindConnect API provides following data ingestion functionalities:

# Data Point Mappings

Creating and managing mappings between an agent's data points and an entity's dynamic property to be able to upload TimeSeries data.

Each agent has data points with unique ids. The mapping is between to this id to an entity's dynamic property set's property.

- A data point can be mapped to many property of many property set of many
entities.

- A property cannot be mapped from more than one data point.

- A propertyset can have mappings from many agents' many data points to its
properties.

- The unit of the datapoint has to be same with the unit of the property.

- The type of the datapoint has to be same with the type of the property.

Whenever data source configuration of an agent is updated via Agent Management API; all mappings with __keepMapping__ attribute set gets their validity attribute updated and all mappings with __keepMapping__ attribute unset are deleted.

# Exchange

Exchanging time series, events, files and data source configuration data. Combination of different data types can be uploaded via exchange endpoint within  multipart body. Maximum size of exchange body is 10MBs.

# Diagnostic Activations

Management of Diagnostic Activations and querying Diagnostic Messages of time series, event, file and data source configuration requests.

- Maximum 5 agents per tenant can be activated for data ingestion tracking.

- For non-agents, the required permission allows to manage diagnostic activation resources of agents in the same tenant as in the token.

- For agents, only the diagnostic activation related to the agent can be managed. Agents are forbidden to view/change the resources of other agents in the same tenant.

- Agents are allowed to update activation for itself only. Users with sufficient scopes are allowed
*/
type McAPI struct {
	spec            *loads.Document
	context         *middleware.Context
	handlers        map[string]map[string]http.Handler
	formats         strfmt.Registry
	customConsumers map[string]runtime.Consumer
	customProducers map[string]runtime.Producer
	defaultConsumes string
	defaultProduces string
	Middleware      func(middleware.Builder) http.Handler
	useSwaggerUI    bool

	// BasicAuthenticator generates a runtime.Authenticator from the supplied basic auth function.
	// It has a default implementation in the security package, however you can replace it for your particular usage.
	BasicAuthenticator func(security.UserPassAuthentication) runtime.Authenticator

	// APIKeyAuthenticator generates a runtime.Authenticator from the supplied token auth function.
	// It has a default implementation in the security package, however you can replace it for your particular usage.
	APIKeyAuthenticator func(string, string, security.TokenAuthentication) runtime.Authenticator

	// BearerAuthenticator generates a runtime.Authenticator from the supplied bearer token auth function.
	// It has a default implementation in the security package, however you can replace it for your particular usage.
	BearerAuthenticator func(string, security.ScopedTokenAuthentication) runtime.Authenticator

	// JSONConsumer registers a consumer for the following mime types:
	//   - application/json
	JSONConsumer runtime.Consumer
	// MultipartMixedConsumer registers a consumer for the following mime types:
	//   - multipart/mixed
	MultipartMixedConsumer runtime.Consumer

	// JSONProducer registers a producer for the following mime types:
	//   - application/json
	JSONProducer runtime.Producer

	// DiagnosticActivationsAuth registers a function that takes an access token and a collection of required scopes and returns a principal
	// it performs authentication based on an oauth2 bearer token provided in the request
	DiagnosticActivationsAuth func(string, []string) (*models.Principal, error)

	// DiagnosticInformationAuth registers a function that takes an access token and a collection of required scopes and returns a principal
	// it performs authentication based on an oauth2 bearer token provided in the request
	DiagnosticInformationAuth func(string, []string) (*models.Principal, error)

	// ExchangeAuth registers a function that takes an access token and a collection of required scopes and returns a principal
	// it performs authentication based on an oauth2 bearer token provided in the request
	ExchangeAuth func(string, []string) (*models.Principal, error)

	// MappingsAuth registers a function that takes an access token and a collection of required scopes and returns a principal
	// it performs authentication based on an oauth2 bearer token provided in the request
	MappingsAuth func(string, []string) (*models.Principal, error)

	// RecordRecoveryAuth registers a function that takes an access token and a collection of required scopes and returns a principal
	// it performs authentication based on an oauth2 bearer token provided in the request
	RecordRecoveryAuth func(string, []string) (*models.Principal, error)

	// APIAuthorizer provides access control (ACL/RBAC/ABAC) by providing access to the request and authenticated principal
	APIAuthorizer runtime.Authorizer

	// MappingsDeleteDataPointMappingsIDHandler sets the operation handler for the delete data point mappings ID operation
	MappingsDeleteDataPointMappingsIDHandler mappings.DeleteDataPointMappingsIDHandler
	// DiagnosticActivationsDeleteDiagnosticActivationsIDHandler sets the operation handler for the delete diagnostic activations ID operation
	DiagnosticActivationsDeleteDiagnosticActivationsIDHandler diagnostic_activations.DeleteDiagnosticActivationsIDHandler
	// RecordRecoveryDeleteRecoverableRecordsIDHandler sets the operation handler for the delete recoverable records ID operation
	RecordRecoveryDeleteRecoverableRecordsIDHandler record_recovery.DeleteRecoverableRecordsIDHandler
	// MappingsGetDataPointMappingsHandler sets the operation handler for the get data point mappings operation
	MappingsGetDataPointMappingsHandler mappings.GetDataPointMappingsHandler
	// MappingsGetDataPointMappingsIDHandler sets the operation handler for the get data point mappings ID operation
	MappingsGetDataPointMappingsIDHandler mappings.GetDataPointMappingsIDHandler
	// DiagnosticActivationsGetDiagnosticActivationsHandler sets the operation handler for the get diagnostic activations operation
	DiagnosticActivationsGetDiagnosticActivationsHandler diagnostic_activations.GetDiagnosticActivationsHandler
	// DiagnosticActivationsGetDiagnosticActivationsIDHandler sets the operation handler for the get diagnostic activations ID operation
	DiagnosticActivationsGetDiagnosticActivationsIDHandler diagnostic_activations.GetDiagnosticActivationsIDHandler
	// DiagnosticActivationsGetDiagnosticActivationsIDMessagesHandler sets the operation handler for the get diagnostic activations ID messages operation
	DiagnosticActivationsGetDiagnosticActivationsIDMessagesHandler diagnostic_activations.GetDiagnosticActivationsIDMessagesHandler
	// DiagnosticInformationGetDiagnosticInformationHandler sets the operation handler for the get diagnostic information operation
	DiagnosticInformationGetDiagnosticInformationHandler diagnostic_information.GetDiagnosticInformationHandler
	// RecordRecoveryGetRecoverableRecordsHandler sets the operation handler for the get recoverable records operation
	RecordRecoveryGetRecoverableRecordsHandler record_recovery.GetRecoverableRecordsHandler
	// RecordRecoveryGetRecoverableRecordsIDDownloadLinkHandler sets the operation handler for the get recoverable records ID download link operation
	RecordRecoveryGetRecoverableRecordsIDDownloadLinkHandler record_recovery.GetRecoverableRecordsIDDownloadLinkHandler
	// MappingsPostDataPointMappingsHandler sets the operation handler for the post data point mappings operation
	MappingsPostDataPointMappingsHandler mappings.PostDataPointMappingsHandler
	// DiagnosticActivationsPostDiagnosticActivationsHandler sets the operation handler for the post diagnostic activations operation
	DiagnosticActivationsPostDiagnosticActivationsHandler diagnostic_activations.PostDiagnosticActivationsHandler
	// ExchangePostExchangeHandler sets the operation handler for the post exchange operation
	ExchangePostExchangeHandler exchange.PostExchangeHandler
	// RecordRecoveryPostRecoverableRecordsIDReplayHandler sets the operation handler for the post recoverable records ID replay operation
	RecordRecoveryPostRecoverableRecordsIDReplayHandler record_recovery.PostRecoverableRecordsIDReplayHandler
	// DiagnosticActivationsPutDiagnosticActivationsIDHandler sets the operation handler for the put diagnostic activations ID operation
	DiagnosticActivationsPutDiagnosticActivationsIDHandler diagnostic_activations.PutDiagnosticActivationsIDHandler

	// ServeError is called when an error is received, there is a default handler
	// but you can set your own with this
	ServeError func(http.ResponseWriter, *http.Request, error)

	// PreServerShutdown is called before the HTTP(S) server is shutdown
	// This allows for custom functions to get executed before the HTTP(S) server stops accepting traffic
	PreServerShutdown func()

	// ServerShutdown is called when the HTTP(S) server is shut down and done
	// handling all active connections and does not accept connections any more
	ServerShutdown func()

	// Custom command line argument groups with their descriptions
	CommandLineOptionsGroups []swag.CommandLineOptionsGroup

	// User defined logger function.
	Logger func(string, ...interface{})
}

// UseRedoc for documentation at /docs
func (o *McAPI) UseRedoc() {
	o.useSwaggerUI = false
}

// UseSwaggerUI for documentation at /docs
func (o *McAPI) UseSwaggerUI() {
	o.useSwaggerUI = true
}

// SetDefaultProduces sets the default produces media type
func (o *McAPI) SetDefaultProduces(mediaType string) {
	o.defaultProduces = mediaType
}

// SetDefaultConsumes returns the default consumes media type
func (o *McAPI) SetDefaultConsumes(mediaType string) {
	o.defaultConsumes = mediaType
}

// SetSpec sets a spec that will be served for the clients.
func (o *McAPI) SetSpec(spec *loads.Document) {
	o.spec = spec
}

// DefaultProduces returns the default produces media type
func (o *McAPI) DefaultProduces() string {
	return o.defaultProduces
}

// DefaultConsumes returns the default consumes media type
func (o *McAPI) DefaultConsumes() string {
	return o.defaultConsumes
}

// Formats returns the registered string formats
func (o *McAPI) Formats() strfmt.Registry {
	return o.formats
}

// RegisterFormat registers a custom format validator
func (o *McAPI) RegisterFormat(name string, format strfmt.Format, validator strfmt.Validator) {
	o.formats.Add(name, format, validator)
}

// Validate validates the registrations in the McAPI
func (o *McAPI) Validate() error {
	var unregistered []string

	if o.JSONConsumer == nil {
		unregistered = append(unregistered, "JSONConsumer")
	}
	if o.MultipartMixedConsumer == nil {
		unregistered = append(unregistered, "MultipartMixedConsumer")
	}

	if o.JSONProducer == nil {
		unregistered = append(unregistered, "JSONProducer")
	}

	if o.DiagnosticActivationsAuth == nil {
		unregistered = append(unregistered, "DiagnosticActivationsAuth")
	}
	if o.DiagnosticInformationAuth == nil {
		unregistered = append(unregistered, "DiagnosticInformationAuth")
	}
	if o.ExchangeAuth == nil {
		unregistered = append(unregistered, "ExchangeAuth")
	}
	if o.MappingsAuth == nil {
		unregistered = append(unregistered, "MappingsAuth")
	}
	if o.RecordRecoveryAuth == nil {
		unregistered = append(unregistered, "RecordRecoveryAuth")
	}

	if o.MappingsDeleteDataPointMappingsIDHandler == nil {
		unregistered = append(unregistered, "mappings.DeleteDataPointMappingsIDHandler")
	}
	if o.DiagnosticActivationsDeleteDiagnosticActivationsIDHandler == nil {
		unregistered = append(unregistered, "diagnostic_activations.DeleteDiagnosticActivationsIDHandler")
	}
	if o.RecordRecoveryDeleteRecoverableRecordsIDHandler == nil {
		unregistered = append(unregistered, "record_recovery.DeleteRecoverableRecordsIDHandler")
	}
	if o.MappingsGetDataPointMappingsHandler == nil {
		unregistered = append(unregistered, "mappings.GetDataPointMappingsHandler")
	}
	if o.MappingsGetDataPointMappingsIDHandler == nil {
		unregistered = append(unregistered, "mappings.GetDataPointMappingsIDHandler")
	}
	if o.DiagnosticActivationsGetDiagnosticActivationsHandler == nil {
		unregistered = append(unregistered, "diagnostic_activations.GetDiagnosticActivationsHandler")
	}
	if o.DiagnosticActivationsGetDiagnosticActivationsIDHandler == nil {
		unregistered = append(unregistered, "diagnostic_activations.GetDiagnosticActivationsIDHandler")
	}
	if o.DiagnosticActivationsGetDiagnosticActivationsIDMessagesHandler == nil {
		unregistered = append(unregistered, "diagnostic_activations.GetDiagnosticActivationsIDMessagesHandler")
	}
	if o.DiagnosticInformationGetDiagnosticInformationHandler == nil {
		unregistered = append(unregistered, "diagnostic_information.GetDiagnosticInformationHandler")
	}
	if o.RecordRecoveryGetRecoverableRecordsHandler == nil {
		unregistered = append(unregistered, "record_recovery.GetRecoverableRecordsHandler")
	}
	if o.RecordRecoveryGetRecoverableRecordsIDDownloadLinkHandler == nil {
		unregistered = append(unregistered, "record_recovery.GetRecoverableRecordsIDDownloadLinkHandler")
	}
	if o.MappingsPostDataPointMappingsHandler == nil {
		unregistered = append(unregistered, "mappings.PostDataPointMappingsHandler")
	}
	if o.DiagnosticActivationsPostDiagnosticActivationsHandler == nil {
		unregistered = append(unregistered, "diagnostic_activations.PostDiagnosticActivationsHandler")
	}
	if o.ExchangePostExchangeHandler == nil {
		unregistered = append(unregistered, "exchange.PostExchangeHandler")
	}
	if o.RecordRecoveryPostRecoverableRecordsIDReplayHandler == nil {
		unregistered = append(unregistered, "record_recovery.PostRecoverableRecordsIDReplayHandler")
	}
	if o.DiagnosticActivationsPutDiagnosticActivationsIDHandler == nil {
		unregistered = append(unregistered, "diagnostic_activations.PutDiagnosticActivationsIDHandler")
	}

	if len(unregistered) > 0 {
		return fmt.Errorf("missing registration: %s", strings.Join(unregistered, ", "))
	}

	return nil
}

// ServeErrorFor gets a error handler for a given operation id
func (o *McAPI) ServeErrorFor(operationID string) func(http.ResponseWriter, *http.Request, error) {
	return o.ServeError
}

// AuthenticatorsFor gets the authenticators for the specified security schemes
func (o *McAPI) AuthenticatorsFor(schemes map[string]spec.SecurityScheme) map[string]runtime.Authenticator {
	result := make(map[string]runtime.Authenticator)
	for name := range schemes {
		switch name {
		case "diagnosticActivations":
			result[name] = o.BearerAuthenticator(name, func(token string, scopes []string) (interface{}, error) {
				return o.DiagnosticActivationsAuth(token, scopes)
			})

		case "diagnosticInformation":
			result[name] = o.BearerAuthenticator(name, func(token string, scopes []string) (interface{}, error) {
				return o.DiagnosticInformationAuth(token, scopes)
			})

		case "exchange":
			result[name] = o.BearerAuthenticator(name, func(token string, scopes []string) (interface{}, error) {
				return o.ExchangeAuth(token, scopes)
			})

		case "mappings":
			result[name] = o.BearerAuthenticator(name, func(token string, scopes []string) (interface{}, error) {
				return o.MappingsAuth(token, scopes)
			})

		case "recordRecovery":
			result[name] = o.BearerAuthenticator(name, func(token string, scopes []string) (interface{}, error) {
				return o.RecordRecoveryAuth(token, scopes)
			})

		}
	}
	return result
}

// Authorizer returns the registered authorizer
func (o *McAPI) Authorizer() runtime.Authorizer {
	return o.APIAuthorizer
}

// ConsumersFor gets the consumers for the specified media types.
// MIME type parameters are ignored here.
func (o *McAPI) ConsumersFor(mediaTypes []string) map[string]runtime.Consumer {
	result := make(map[string]runtime.Consumer, len(mediaTypes))
	for _, mt := range mediaTypes {
		switch mt {
		case "application/json":
			result["application/json"] = o.JSONConsumer
		case "multipart/mixed":
			result["multipart/mixed"] = o.MultipartMixedConsumer
		}

		if c, ok := o.customConsumers[mt]; ok {
			result[mt] = c
		}
	}
	return result
}

// ProducersFor gets the producers for the specified media types.
// MIME type parameters are ignored here.
func (o *McAPI) ProducersFor(mediaTypes []string) map[string]runtime.Producer {
	result := make(map[string]runtime.Producer, len(mediaTypes))
	for _, mt := range mediaTypes {
		switch mt {
		case "application/json":
			result["application/json"] = o.JSONProducer
		}

		if p, ok := o.customProducers[mt]; ok {
			result[mt] = p
		}
	}
	return result
}

// HandlerFor gets a http.Handler for the provided operation method and path
func (o *McAPI) HandlerFor(method, path string) (http.Handler, bool) {
	if o.handlers == nil {
		return nil, false
	}
	um := strings.ToUpper(method)
	if _, ok := o.handlers[um]; !ok {
		return nil, false
	}
	if path == "/" {
		path = ""
	}
	h, ok := o.handlers[um][path]
	return h, ok
}

// Context returns the middleware context for the mc API
func (o *McAPI) Context() *middleware.Context {
	if o.context == nil {
		o.context = middleware.NewRoutableContext(o.spec, o, nil)
	}

	return o.context
}

func (o *McAPI) initHandlerCache() {
	o.Context() // don't care about the result, just that the initialization happened
	if o.handlers == nil {
		o.handlers = make(map[string]map[string]http.Handler)
	}

	if o.handlers["DELETE"] == nil {
		o.handlers["DELETE"] = make(map[string]http.Handler)
	}
	o.handlers["DELETE"]["/dataPointMappings/{id}"] = mappings.NewDeleteDataPointMappingsID(o.context, o.MappingsDeleteDataPointMappingsIDHandler)
	if o.handlers["DELETE"] == nil {
		o.handlers["DELETE"] = make(map[string]http.Handler)
	}
	o.handlers["DELETE"]["/diagnosticActivations/{id}"] = diagnostic_activations.NewDeleteDiagnosticActivationsID(o.context, o.DiagnosticActivationsDeleteDiagnosticActivationsIDHandler)
	if o.handlers["DELETE"] == nil {
		o.handlers["DELETE"] = make(map[string]http.Handler)
	}
	o.handlers["DELETE"]["/recoverableRecords/{id}"] = record_recovery.NewDeleteRecoverableRecordsID(o.context, o.RecordRecoveryDeleteRecoverableRecordsIDHandler)
	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/dataPointMappings"] = mappings.NewGetDataPointMappings(o.context, o.MappingsGetDataPointMappingsHandler)
	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/dataPointMappings/{id}"] = mappings.NewGetDataPointMappingsID(o.context, o.MappingsGetDataPointMappingsIDHandler)
	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/diagnosticActivations"] = diagnostic_activations.NewGetDiagnosticActivations(o.context, o.DiagnosticActivationsGetDiagnosticActivationsHandler)
	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/diagnosticActivations/{id}"] = diagnostic_activations.NewGetDiagnosticActivationsID(o.context, o.DiagnosticActivationsGetDiagnosticActivationsIDHandler)
	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/diagnosticActivations/{id}/messages"] = diagnostic_activations.NewGetDiagnosticActivationsIDMessages(o.context, o.DiagnosticActivationsGetDiagnosticActivationsIDMessagesHandler)
	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/diagnosticInformation"] = diagnostic_information.NewGetDiagnosticInformation(o.context, o.DiagnosticInformationGetDiagnosticInformationHandler)
	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/recoverableRecords"] = record_recovery.NewGetRecoverableRecords(o.context, o.RecordRecoveryGetRecoverableRecordsHandler)
	if o.handlers["GET"] == nil {
		o.handlers["GET"] = make(map[string]http.Handler)
	}
	o.handlers["GET"]["/recoverableRecords/{id}/downloadLink"] = record_recovery.NewGetRecoverableRecordsIDDownloadLink(o.context, o.RecordRecoveryGetRecoverableRecordsIDDownloadLinkHandler)
	if o.handlers["POST"] == nil {
		o.handlers["POST"] = make(map[string]http.Handler)
	}
	o.handlers["POST"]["/dataPointMappings"] = mappings.NewPostDataPointMappings(o.context, o.MappingsPostDataPointMappingsHandler)
	if o.handlers["POST"] == nil {
		o.handlers["POST"] = make(map[string]http.Handler)
	}
	o.handlers["POST"]["/diagnosticActivations"] = diagnostic_activations.NewPostDiagnosticActivations(o.context, o.DiagnosticActivationsPostDiagnosticActivationsHandler)
	if o.handlers["POST"] == nil {
		o.handlers["POST"] = make(map[string]http.Handler)
	}
	o.handlers["POST"]["/exchange"] = exchange.NewPostExchange(o.context, o.ExchangePostExchangeHandler)
	if o.handlers["POST"] == nil {
		o.handlers["POST"] = make(map[string]http.Handler)
	}
	o.handlers["POST"]["/recoverableRecords/{id}/replay"] = record_recovery.NewPostRecoverableRecordsIDReplay(o.context, o.RecordRecoveryPostRecoverableRecordsIDReplayHandler)
	if o.handlers["PUT"] == nil {
		o.handlers["PUT"] = make(map[string]http.Handler)
	}
	o.handlers["PUT"]["/diagnosticActivations/{id}"] = diagnostic_activations.NewPutDiagnosticActivationsID(o.context, o.DiagnosticActivationsPutDiagnosticActivationsIDHandler)
}

// Serve creates a http handler to serve the API over HTTP
// can be used directly in http.ListenAndServe(":8000", api.Serve(nil))
func (o *McAPI) Serve(builder middleware.Builder) http.Handler {
	o.Init()

	if o.Middleware != nil {
		return o.Middleware(builder)
	}
	if o.useSwaggerUI {
		return o.context.APIHandlerSwaggerUI(builder)
	}
	return o.context.APIHandler(builder)
}

// Init allows you to just initialize the handler cache, you can then recompose the middleware as you see fit
func (o *McAPI) Init() {
	if len(o.handlers) == 0 {
		o.initHandlerCache()
	}
}

// RegisterConsumer allows you to add (or override) a consumer for a media type.
func (o *McAPI) RegisterConsumer(mediaType string, consumer runtime.Consumer) {
	o.customConsumers[mediaType] = consumer
}

// RegisterProducer allows you to add (or override) a producer for a media type.
func (o *McAPI) RegisterProducer(mediaType string, producer runtime.Producer) {
	o.customProducers[mediaType] = producer
}

// AddMiddlewareFor adds a http middleware to existing handler
func (o *McAPI) AddMiddlewareFor(method, path string, builder middleware.Builder) {
	um := strings.ToUpper(method)
	if path == "/" {
		path = ""
	}
	o.Init()
	if h, ok := o.handlers[um][path]; ok {
		o.handlers[method][path] = builder(h)
	}
}
