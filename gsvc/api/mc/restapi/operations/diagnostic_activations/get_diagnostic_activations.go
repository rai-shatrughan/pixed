// Code generated by go-swagger; DO NOT EDIT.

package diagnostic_activations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the generate command

import (
	"net/http"

	"github.com/go-openapi/runtime/middleware"

	"gsvc/api/mc/models"
)

// GetDiagnosticActivationsHandlerFunc turns a function with the right signature into a get diagnostic activations handler
type GetDiagnosticActivationsHandlerFunc func(GetDiagnosticActivationsParams, *models.Principal) middleware.Responder

// Handle executing the request and returning a response
func (fn GetDiagnosticActivationsHandlerFunc) Handle(params GetDiagnosticActivationsParams, principal *models.Principal) middleware.Responder {
	return fn(params, principal)
}

// GetDiagnosticActivationsHandler interface for that can handle valid get diagnostic activations params
type GetDiagnosticActivationsHandler interface {
	Handle(GetDiagnosticActivationsParams, *models.Principal) middleware.Responder
}

// NewGetDiagnosticActivations creates a new http.Handler for the get diagnostic activations operation
func NewGetDiagnosticActivations(ctx *middleware.Context, handler GetDiagnosticActivationsHandler) *GetDiagnosticActivations {
	return &GetDiagnosticActivations{Context: ctx, Handler: handler}
}

/*
	GetDiagnosticActivations swagger:route GET /diagnosticActivations Diagnostic Activations getDiagnosticActivations

# Gets diagnostic activations

Get diagnostic activations. Agents are allowed to get their own activation. Users with sufficient scopes are allowed to get all activations in the same tenant as in the token.
*/
type GetDiagnosticActivations struct {
	Context *middleware.Context
	Handler GetDiagnosticActivationsHandler
}

func (o *GetDiagnosticActivations) ServeHTTP(rw http.ResponseWriter, r *http.Request) {
	route, rCtx, _ := o.Context.RouteInfo(r)
	if rCtx != nil {
		*r = *rCtx
	}
	var Params = NewGetDiagnosticActivationsParams()
	uprinc, aCtx, err := o.Context.Authorize(r, route)
	if err != nil {
		o.Context.Respond(rw, r, route.Produces, route, err)
		return
	}
	if aCtx != nil {
		*r = *aCtx
	}
	var principal *models.Principal
	if uprinc != nil {
		principal = uprinc.(*models.Principal) // this is really a models.Principal, I promise
	}

	if err := o.Context.BindValidRequest(r, route, &Params); err != nil { // bind params
		o.Context.Respond(rw, r, route.Produces, route, err)
		return
	}

	res := o.Handler.Handle(Params, principal) // actually handle the request
	o.Context.Respond(rw, r, route.Produces, route, res)

}
