// Code generated by go-swagger; DO NOT EDIT.

package diagnostic_activations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the generate command

import (
	"net/http"

	"github.com/go-openapi/runtime/middleware"

	"gsvc/api/mc/models"
)

// GetDiagnosticActivationsIDHandlerFunc turns a function with the right signature into a get diagnostic activations ID handler
type GetDiagnosticActivationsIDHandlerFunc func(GetDiagnosticActivationsIDParams, *models.Principal) middleware.Responder

// Handle executing the request and returning a response
func (fn GetDiagnosticActivationsIDHandlerFunc) Handle(params GetDiagnosticActivationsIDParams, principal *models.Principal) middleware.Responder {
	return fn(params, principal)
}

// GetDiagnosticActivationsIDHandler interface for that can handle valid get diagnostic activations ID params
type GetDiagnosticActivationsIDHandler interface {
	Handle(GetDiagnosticActivationsIDParams, *models.Principal) middleware.Responder
}

// NewGetDiagnosticActivationsID creates a new http.Handler for the get diagnostic activations ID operation
func NewGetDiagnosticActivationsID(ctx *middleware.Context, handler GetDiagnosticActivationsIDHandler) *GetDiagnosticActivationsID {
	return &GetDiagnosticActivationsID{Context: ctx, Handler: handler}
}

/*
	GetDiagnosticActivationsID swagger:route GET /diagnosticActivations/{id} Diagnostic Activations getDiagnosticActivationsId

Gets a diagnostic activation.

Get a diagnostic activation with given id.  Agents are allowed to get their own activation. Users with sufficient scopes are allowed to get any activation in the same tenant as in the token.
*/
type GetDiagnosticActivationsID struct {
	Context *middleware.Context
	Handler GetDiagnosticActivationsIDHandler
}

func (o *GetDiagnosticActivationsID) ServeHTTP(rw http.ResponseWriter, r *http.Request) {
	route, rCtx, _ := o.Context.RouteInfo(r)
	if rCtx != nil {
		*r = *rCtx
	}
	var Params = NewGetDiagnosticActivationsIDParams()
	uprinc, aCtx, err := o.Context.Authorize(r, route)
	if err != nil {
		o.Context.Respond(rw, r, route.Produces, route, err)
		return
	}
	if aCtx != nil {
		*r = *aCtx
	}
	var principal *models.Principal
	if uprinc != nil {
		principal = uprinc.(*models.Principal) // this is really a models.Principal, I promise
	}

	if err := o.Context.BindValidRequest(r, route, &Params); err != nil { // bind params
		o.Context.Respond(rw, r, route.Produces, route, err)
		return
	}

	res := o.Handler.Handle(Params, principal) // actually handle the request
	o.Context.Respond(rw, r, route.Produces, route, res)

}
