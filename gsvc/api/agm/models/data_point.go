// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// DataPoint data point
//
// swagger:model DataPoint
type DataPoint struct {

	// A list of string tuples. Max 5 tuples allowed.
	// Example: {"Nominal":"~220 Volts"}
	CustomData map[string]string `json:"customData,omitempty"`

	// description
	// Example: Voltage value read.
	// Max Length: 256
	Description string `json:"description,omitempty"`

	// Identifier of this data point. This id needs to be unique per data source configuration. Agents expected to upload timeseries value with this id, enabling backend services to match data with this data point.
	// This is NOT an auto generated field, enabling agents to specify it before uploading matching timeseries value.
	//
	// Example: DP001
	// Required: true
	// Max Length: 36
	ID *string `json:"id"`

	// name
	// Example: Voltage
	// Required: true
	// Max Length: 64
	Name *string `json:"name"`

	// type
	// Example: DOUBLE
	// Required: true
	// Enum: [INT LONG DOUBLE BOOLEAN STRING]
	Type *string `json:"type"`

	// Unit of data point. Can be empty.
	//
	// Example: V
	// Required: true
	// Max Length: 32
	Unit *string `json:"unit"`
}

// Validate validates this data point
func (m *DataPoint) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCustomData(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDescription(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUnit(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DataPoint) validateCustomData(formats strfmt.Registry) error {
	if swag.IsZero(m.CustomData) { // not required
		return nil
	}

	for k := range m.CustomData {

		if err := validate.MaxLength("customData"+"."+k, "body", m.CustomData[k], 1024); err != nil {
			return err
		}

	}

	return nil
}

func (m *DataPoint) validateDescription(formats strfmt.Registry) error {
	if swag.IsZero(m.Description) { // not required
		return nil
	}

	if err := validate.MaxLength("description", "body", m.Description, 256); err != nil {
		return err
	}

	return nil
}

func (m *DataPoint) validateID(formats strfmt.Registry) error {

	if err := validate.Required("id", "body", m.ID); err != nil {
		return err
	}

	if err := validate.MaxLength("id", "body", *m.ID, 36); err != nil {
		return err
	}

	return nil
}

func (m *DataPoint) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	if err := validate.MaxLength("name", "body", *m.Name, 64); err != nil {
		return err
	}

	return nil
}

var dataPointTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["INT","LONG","DOUBLE","BOOLEAN","STRING"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dataPointTypeTypePropEnum = append(dataPointTypeTypePropEnum, v)
	}
}

const (

	// DataPointTypeINT captures enum value "INT"
	DataPointTypeINT string = "INT"

	// DataPointTypeLONG captures enum value "LONG"
	DataPointTypeLONG string = "LONG"

	// DataPointTypeDOUBLE captures enum value "DOUBLE"
	DataPointTypeDOUBLE string = "DOUBLE"

	// DataPointTypeBOOLEAN captures enum value "BOOLEAN"
	DataPointTypeBOOLEAN string = "BOOLEAN"

	// DataPointTypeSTRING captures enum value "STRING"
	DataPointTypeSTRING string = "STRING"
)

// prop value enum
func (m *DataPoint) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, dataPointTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *DataPoint) validateType(formats strfmt.Registry) error {

	if err := validate.Required("type", "body", m.Type); err != nil {
		return err
	}

	// value enum
	if err := m.validateTypeEnum("type", "body", *m.Type); err != nil {
		return err
	}

	return nil
}

func (m *DataPoint) validateUnit(formats strfmt.Registry) error {

	if err := validate.Required("unit", "body", m.Unit); err != nil {
		return err
	}

	if err := validate.MaxLength("unit", "body", *m.Unit, 32); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this data point based on context it is used
func (m *DataPoint) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DataPoint) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DataPoint) UnmarshalBinary(b []byte) error {
	var res DataPoint
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
